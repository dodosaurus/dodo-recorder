# Dodo Recorder â€” Complete Project Deep Dive

**Document Purpose:** A comprehensive guide to understanding Dodo Recorder from the ground up. This document covers the project's vision, architecture, implementation details, feature states, and everything you might have forgotten about how it was built.

**Last Updated:** February 9, 2026  
**Current Version:** 0.3.0  
**Author:** Jozef Kovac

---

## Table of Contents

1. [Project Vision & Core Philosophy](#project-vision--core-philosophy)
2. [High-Level Architecture](#high-level-architecture)
3. [Technical Stack Deep Dive](#technical-stack-deep-dive)
4. [Core Components & Their Implementation](#core-components--their-implementation)
5. [Key Features & Their Current State](#key-features--their-current-state)
6. [Data Flow & Recording Lifecycle](#data-flow--recording-lifecycle)
7. [Voice Transcription Pipeline](#voice-transcription-pipeline)
8. [Session Output Format](#session-output-format)
9. [Browser Recording & Widget System](#browser-recording--widget-system)
10. [UI Architecture](#ui-architecture)
11. [State Management](#state-management)
12. [Settings & Persistence](#settings--persistence)
13. [Logging & Debugging](#logging--debugging)
14. [Build System & Distribution](#build-system--distribution)
15. [Known Issues & TODO](#known-issues--todo)
16. [Development Guidelines](#development-guidelines)
17. [Future Directions](#future-directions)

---

## Project Vision & Core Philosophy

### The Problem Being Solved

Traditional automated test generation suffers from a disconnect between:

1. **Manual testers** who understand application behavior but don't write code
2. **Test automation engineers** who write tests but may lack deep application knowledge
3. **AI tools** that generate code but lack context and human oversight

### The Dodo Recorder Approach

Dodo Recorder implements a **three-actor system**:

| Actor | Role | Tools | Responsibilities |
|-------|------|-------|------------------|
| **Manual Tester** | Explore & record | Dodo Recorder app | Navigate app, speak commentary, record interactions |
| **Engineer/Gatekeeper** | Review & approve | IDE/CLI + AI tools | Review sessions, invoke AI, approve code |
| **AI System** | Generate code | LLM + Playwright | Interpret sessions, generate/refactor tests |

### Core Principles

1. **Observation â‰  Interpretation â‰  Code Generation**
   - Recorder captures *facts* only (no interpretation)
   - AI interprets intent from commentary + actions
   - Tests are generated by AI, approved by humans

2. **Black-Box Testing Only**
   - No access to production code
   - No application internals
   - Tests from user perspective

3. **Human-in-the-Loop**
   - No code enters repo without engineer approval
   - Full transparency and control

4. **Deterministic Output**
   - Standard Playwright repository
   - No AI dependency at test runtime
   - CI-friendly and rerunnable

### What Makes Dodo Recorder Unique

| Feature | Benefit |
|---------|---------|
| **Voice Sync** | Natural language intent captured alongside actions |
| **Local Processing** | All transcription happens offline via Whisper.cpp |
| **Framework-Agnostic Output** | Works with Playwright, Cypress, Selenium, Puppeteer |
| **AI-Optimized Bundles** | Complete instructions embedded, no external docs needed |
| **Rich Locator Extraction** | Multiple strategies (testId, role, text, CSS, XPath) with confidence levels |
| **Assertion Mode** | Visual feedback when asserting elements |

---

## High-Level Architecture

### Two-Process Electron Model

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Main Process                         â”‚
â”‚  (Node.js backend, full OS access)                   â”‚
â”‚                                                     â”‚
â”‚  â€¢ Application lifecycle                              â”‚
â”‚  â€¢ Browser window management                          â”‚
â”‚  â€¢ IPC handlers                                     â”‚
â”‚  â€¢ Playwright browser control                        â”‚
â”‚  â€¢ Whisper transcription                            â”‚
â”‚  â€¢ File system operations                            â”‚
â”‚  â€¢ Settings persistence                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚ IPC (Inter-Process Communication)
                    â”‚ via preload.ts
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Renderer Process                         â”‚
â”‚  (React UI running in Chromium sandbox)                â”‚
â”‚                                                     â”‚
â”‚  â€¢ User interface                                   â”‚
â”‚  â€¢ Recording controls                               â”‚
â”‚  â€¢ Audio capture                                   â”‚
â”‚  â€¢ State display                                   â”‚
â”‚  â€¢ Transcript viewing                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Communication Layer

**Renderer â†’ Main** (via `window.electronAPI`):
```typescript
// Controlled actions from UI
window.electronAPI.startRecording(url, outputPath, startTime)
window.electronAPI.stopRecording()
window.electronAPI.transcribeAudio(audioBuffer)
window.electronAPI.distributeVoiceSegments(actions, segments)
window.electronAPI.saveSession(bundle)
```

**Main â†’ Renderer** (via `mainWindow.webContents.send()`):
```typescript
// Events and state updates
mainWindow.webContents.send('action-recorded', action)
mainWindow.webContents.send('recording-state-changed', { status: 'paused' })
mainWindow.webContents.send('audio-activity-updated', { isActive })
```

### Component Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Electron App                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Main Process   â”‚      Renderer Process                  â”‚
â”‚                  â”‚                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚   IPC      â”‚ â”‚  â”‚   React UI   â”‚                   â”‚
â”‚  â”‚ Handlers   â”‚â—„â”€â”¼â”€â”€â”¤ Components   â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚       â”‚          â”‚         â”‚                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”‚                           â”‚
â”‚  â”‚             â”‚         â”‚                           â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚  â”‚  â”‚ Browser Recorder  â”‚                            â”‚
â”‚  â”‚  â”‚  (Playwright)    â”‚                            â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â”‚
â”‚  â”‚           â”‚                                      â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  â”‚ Audio Transcriberâ”‚  â”‚ Session Writer    â”‚   â”‚
â”‚  â”‚  â”‚  (Whisper.cpp)  â”‚  â”‚  (File output)   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”‚                                                  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  â”‚ Settings Store (persistent JSON)            â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Technical Stack Deep Dive

### Frontend (Renderer Process)

| Technology | Purpose | Version |
|------------|---------|---------|
| **React 18** | UI library | 18.2.0 |
| **TypeScript** | Type safety | 5.3.2 |
| **Vite** | Build tool & dev server | 5.0.7 |
| **Tailwind CSS** | Styling (dark mode only) | 3.3.6 |
| **Zustand** | State management | 4.4.7 |
| **Lucide React** | Icon library | 0.294.0 |
| **CVA** (class-variance-authority) | Component variants | 0.7.0 |

**Why These Choices:**

- **React + TypeScript**: Industry standard, excellent tooling, strict type checking
- **Vite**: Fast HMR, modern build system, better than CRA for Electron
- **Tailwind**: Rapid UI development, consistent design system
- **Zustand**: Lightweight state management, no boilerplate, perfect for Electron apps
- **Lucide**: Consistent, modern icons that match the dark theme

### Backend (Main Process)

| Technology | Purpose | Version |
|------------|---------|---------|
| **Electron** | Desktop app framework | 28.0.0 |
| **Node.js** | Runtime (required 18+) | - |
| **Playwright** | Browser automation | 1.40.0 |
| **Whisper.cpp** | Local speech-to-text | (bundled binaries) |
| **ffmpeg-static** | Audio processing | 5.3.0 |
| **electron-log** | Production logging | 5.4.3 |
| **uuid** | Unique ID generation | 9.0.1 |

**Why These Choices:**

- **Electron**: Desktop app standard, cross-platform, native browser integration
- **Playwright**: Modern automation, excellent recording API, headless control
- **Whisper.cpp (ggerganov port)**: Local transcription, no cloud, fast CPU performance
- **ffmpeg-static**: Audio format conversion, bundled binary
- **electron-log**: File logging with rotation, production-ready

### Build & Packaging

| Technology | Purpose |
|------------|---------|
| **electron-builder** | Cross-platform packaging and code signing |
| **GitHub Actions** | CI/CD for automated builds |
| **dotenv-cli** | Environment variable management |

---

## Core Components & Their Implementation

### 1. Main Process Entry Point (`electron/main.ts`)

**Responsibilities:**
- Creates the main BrowserWindow (frameless, custom title bar)
- Initializes settings and microphone permissions
- Registers all IPC handlers via `registerAllHandlers()`
- Cleans up temporary files on startup
- Checks for Whisper components (binary + model) on startup
- Logs startup information

**Key Implementation Details:**

```typescript
// Window creation
const mainWindow = new BrowserWindow({
  width: 1200,
  height: 800,
  frame: false,  // Custom title bar
  show: false,   // Show after ready
  webPreferences: {
    preload: path.join(__dirname, 'preload.js'),
    sandbox: true,
    contextIsolation: true,
    nodeIntegration: false,  // Security
  }
})

// Initial content loading
if (isDev) {
  mainWindow.loadURL('http://localhost:5173')
} else {
  mainWindow.loadFile(path.join(__dirname, '../dist/index.html'))
}
```

**Startup Flow:**
1. Initialize logger
2. Clean up temp files
3. Create window
4. Load preload script
5. Load React app
6. Register IPC handlers
7. Check Whisper components
8. Show window (after ready)

---

### 2. IPC Handler System (`electron/ipc/`)

**Architecture:** Central registration with modular handlers

```typescript
// handlers.ts - Central registration
export function registerAllHandlers(mainWindow: BrowserWindow | null) {
  registerRecordingHandlers(mainWindow)
  registerSessionHandlers()
  registerSettingsHandlers()
}

// recording.ts - Recording operations
ipcMain.handle('start-recording', async (event, url, outputPath, startTime) => {
  // Start browser recording
})

// session.ts - Session & settings
ipcMain.handle('save-session', async (event, bundle) => {
  // Save to disk
})
```

**Why This Pattern:**
- Single registration point prevents duplicates
- Modular handlers for different concerns
- Easy to add new IPC calls
- Type-safe via `window.electronAPI` in preload

---

### 3. Browser Recorder (`electron/browser/recorder.ts`)

**Core Function:** Launch Chromium, inject tracking scripts, capture events

**How It Works:**

1. **Launch Browser:**
```typescript
const context = await this.browser.newContext({
  viewport: { width: 1920, height: 1080 }
})
const page = await context.newPage()
```

2. **Inject Scripts Before Page Load:**
```typescript
// Critical: Must inject before any page content loads
await this.page.addInitScript('window.__dodoRecordAction = ' + getInjectedScript().toString())
await this.page.addInitScript('window.__dodoCreateWidget = ' + getWidgetScript().toString())
await this.page.addInitScript('window.__dodoCreateHighlighter = ' + getHighlighterScript().toString())
```

3. **Expose Functions for Injected Script:**
```typescript
// Injected script can call these
await this.page.exposeFunction('__dodoRecordAction', (actionData: string) => {
  const action = JSON.parse(actionData)
  this.emit('action', action)
  mainWindow?.webContents.send('action-recorded', action)
})

await this.page.exposeFunction('__dodoTakeScreenshot', async () => {
  const path = await this.captureScreenshot()
  return path
})
```

4. **Navigate to Start URL:**
```typescript
await this.page.goto(url, { waitUntil: 'networkidle' })
```

5. **Listen for Actions:**
```typescript
this.recorder.on('action', (action) => {
  this.actions.push(action)
})
```

**Why This Approach:**
- Scripts injected before page load â†’ works with SPAs
- Events captured from browser context â†’ authentic user interactions
- No polling â†’ efficient
- Shadow DOM isolation â†’ widget never recorded

---

### 4. Audio Transcriber (`electron/audio/transcriber.ts`)

**Pipeline:**
```
WebM Buffer (16kHz) 
  â†’ FFmpeg conversion (WAV + 1.5s padding) 
  â†’ Whisper.cpp CLI 
  â†’ JSON parsing 
  â†’ Timestamp adjustment (-1500ms)
  â†’ Post-processing (filter hallucinations)
  â†’ TranscriptSegment[]
```

**Key Parameters:**

| Parameter | Value | Purpose |
|-----------|-------|---------|
| Model | `small.en` (466MB) | Balance of speed and accuracy |
| Sample rate | 16kHz | Whisper native format |
| Channels | Mono (1) | Required by Whisper |
| Padding | 1.5s (both ends) | Early speech detection |
| Entropy threshold | 2.0 | Aggressive detection |
| Beam size | 5 | Search breadth |
| Max segment length | 50 chars | Phrase-level segmentation |

**Anti-Hallucination Filtering:**

Problem: Whisper generates text when given silence.

Solution: Two-phase post-processing

```typescript
// Phase 1: Detect repetitive text
const textCounts = new Map<string, number>()
result.forEach(segment => {
  const text = segment.speech.trim()
  textCounts.set(text, (textCounts.get(text) || 0) + 1)
})

const hallucinatedTexts = new Set<string>()
textCounts.forEach((count, text) => {
  if (count >= 2) {
    hallucinatedTexts.add(text)  // Repeated = hallucination
  }
})

// Phase 2: Filter all types
const validSegments = result.filter(segment => {
  const text = segment.speech.trim()
  return text.length > 0 &&
    text !== WHISPER_PROMPT &&              // Remove prompt
    !hallucinatedTexts.has(text) &&       // Remove repetitions
    !text.match(/^\[.*\]$/) &&            // Remove [BLANK_AUDIO]
    !text.match(/^\(.*\)$/) &&            // Remove (noise)
    text.length > 2                        // Min length
})
```

**Why Post-Processing:**
- Cross-version compatible
- Debuggable (can log filtered content)
- Flexible (easy to adjust rules)
- ~95% effective

---

### 5. Voice Distribution (`electron/utils/voiceDistribution.ts`)

**Algorithm:** Associates voice segments with browser actions using temporal proximity

**Time Windows (Current Settings):**
- Lookback: 4 seconds (speech precedes action)
- Lookahead: 2 seconds (confirmations)
- Long segment threshold: 2 seconds

**Distribution Logic:**

```typescript
function distributeVoiceSegments(
  actions: RecordedAction[],
  segments: TranscriptSegment[],
  sessionStartTime: number
): RecordedAction[] {
  // Sort chronologically
  actions.sort((a, b) => a.timestamp - b.timestamp)
  segments.sort((a, b) => a.startTime - b.startTime)

  // For each segment, find nearest actions within window
  segments.forEach(segment => {
    const windowStart = segment.endTime - LOOKBACK_MS
    const windowEnd = segment.startTime + LOOKAHEAD_MS

    const candidates = actions.filter(a =>
      a.timestamp >= windowStart && a.timestamp <= windowEnd
    )

    if (candidates.length === 0) {
      // No actions in window â†’ assign to closest
      assignToClosest(segment, actions)
    } else if (candidates.length === 1) {
      // One action â†’ assign
      candidates[0].voiceSegments ??= []
      candidates[0].voiceSegments.push(segment)
    } else {
      // Multiple actions
      if (isLongSegment(segment)) {
        // Long segment spanning actions â†’ assign to ALL
        candidates.forEach(a => {
          a.voiceSegments ??= []
          a.voiceSegments.push(segment)
        })
      } else {
        // Short segment â†’ assign to closest by midpoint
        const closest = findClosest(candidates, segment)
        closest.voiceSegments ??= []
        closest.voiceSegments.push(segment)
      }
    }
  })
}
```

**Why This Algorithm:**
- Handles natural speech patterns (explaining before doing)
- Captures confirmations after actions
- Distributes long commentary appropriately
- Fallback to closest action when uncertain

**Configuration:**
- Stored in `electron/settings/store.ts`
- User-adjustable via settings
- Defaults used if settings not loaded

---

### 6. Narrative Builder (`shared/narrativeBuilder.ts` / `electron/utils/enhancedTranscript.ts`)

**Purpose:** Generate narrative text with embedded action references for AI consumption

**Key Innovation: Sentence-level distribution**

**Before (segment-level - inferior):**
```
"Clicking login then filling username and password. 
[action:abc:click] [action:def:fill] [action:ghi:fill]"
```
âŒ All actions clustered at end, loses context

**After (sentence-level - superior):**
```
"Clicking login [action:abc:click]. Filling username [action:def:fill]. 
And password [action:ghi:fill]."
```
âœ… Actions adjacent to relevant phrases

**Implementation:**

1. **Split segments into sentences with timestamps:**
```typescript
function splitIntoSentencesWithTimestamps(
  text: string,
  segmentStartTime: number,
  segmentEndTime: number
): SentenceWithTime[] {
  // Split by '.', '!', '?'
  const sentences = text.split(/(?<=[.!?])\s+/)
  
  // Calculate proportional timestamps
  const totalLength = text.length
  let currentTime = segmentStartTime
  
  return sentences.map(sentence => {
    const length = sentence.length
    const proportion = length / totalLength
    const duration = (segmentEndTime - segmentStartTime) * proportion
    
    const sentenceWithTime = {
      text: sentence,
      startTime: currentTime,
      endTime: currentTime + duration
    }
    currentTime += duration
    return sentenceWithTime
  })
}
```

2. **Interleave actions within sentences:**
```typescript
function interleaveActionsInText(
  sentences: SentenceWithTime[],
  actions: RecordedAction[]
): string {
  let output = ''
  
  sentences.forEach(sentence => {
    // Find actions whose timestamp falls within sentence range
    const actionsInSentence = actions.filter(a =>
      a.timestamp >= sentence.startTime && 
      a.timestamp <= sentence.endTime
    )
    
    // Add sentence text
    output += sentence.text + ' '
    
    // Add action references after sentence
    actionsInSentence.forEach(action => {
      const shortId = action.id.substring(0, 8)
      output += `[action:${shortId}:${action.type}] `
    })
  })
  
  return output.trim()
}
```

3. **Build complete narrative:**
```typescript
function buildNarrativeWithSentenceLevelDistribution(
  actions: RecordedAction[]
): string {
  // Collect all unique segments chronologically
  const segments = getAllVoiceSegments(actions)
  
  // Build narrative
  let narrative = ''
  segments.forEach(segment => {
    const actionsWithThisSegment = actions.filter(a =>
      a.voiceSegments?.some(s => s.id === segment.id)
    )
    
    if (actionsWithThisSegment.length === 0) {
      // No actions â†’ add text only
      narrative += segment.text + ' '
    } else {
      // Has actions â†’ split and interleave
      const sentences = splitIntoSentencesWithTimestamps(
        segment.text, 
        segment.startTime, 
        segment.endTime
      )
      narrative += interleaveActionsInText(sentences, actionsWithThisSegment) + ' '
    }
  })
  
  // Append silent actions at end
  const silentActions = actions.filter(a => !a.voiceSegments?.length)
  silentActions.forEach(action => {
    const shortId = action.id.substring(0, 8)
    narrative += `[action:${shortId}:${action.type}] `
  })
  
  return narrative.trim()
}
```

**Why Sentence-Level:**
- 3-5x finer granularity than segment-level
- Actions appear at most relevant locations
- Natural reading flow for AI
- Better context for interpretation

---

### 7. Session Writer (`electron/session/writer.ts`)

**Output Structure:**
```
session-YYYY-MM-DD-HHMMSS/
â”œâ”€â”€ INSTRUCTIONS.md    # Reusable AI instructions
â”œâ”€â”€ actions.json       # _meta + narrative + actions
â””â”€â”€ screenshots/       # PNG files
```

**Implementation:**

```typescript
async write(session: SessionBundle): Promise<string> {
  // 1. Create session directory
  const sessionDir = createSessionDirectory(session)
  
  // 2. Ensure INSTRUCTIONS.md exists (write once per directory)
  await ensureInstructionsFile(sessionDir)
  
  // 3. Generate narrative text
  const narrativeText = buildNarrativeWithSentenceLevelDistribution(session.actions)
  
  // 4. Build actions.json
  const actionsJson = {
    _meta: {
      formatVersion: "2.0",
      generatedBy: "Dodo Recorder",
      sessionId: session.sessionId,
      startTime: session.startTime,
      startTimeISO: new Date(session.startTime).toISOString(),
      duration: calculateDuration(session.actions),
      startUrl: session.startUrl,
      totalActions: session.actions.length,
      actionTypes: countActionTypes(session.actions)
    },
    narrative: {
      text: narrativeText,
      note: "Voice commentary with embedded action references. Match SHORT_ID (first 8 chars) with action.id in actions array."
    },
    actions: stripVoiceSegments(session.actions)  // Remove voiceSegments for output
  }
  
  // 5. Write actions.json
  await writeJson(
    path.join(sessionDir, 'actions.json'),
    actionsJson,
    { spaces: 2 }
  )
  
  // 6. Copy screenshots
  await copyScreenshots(session.screenshots, sessionDir)
  
  return sessionDir
}
```

**Why This Structure:**

- **Token-efficient**: INSTRUCTIONS.md shared across sessions
- **Single source**: All session data in one JSON file
- **AI-ready**: Complete instructions embedded
- **Human-readable**: Clear metadata and narrative flow

---

### 8. Settings Store (`electron/settings/store.ts`)

**Persistent JSON storage in user data directory:**

```typescript
interface AppSettings {
  whisper: {
    transcriptionTimeoutMs: number  // 300000 (5 minutes)
  }
  voiceDistribution: {
    lookbackMs: number        // 4000ms (4 seconds)
    lookaheadMs: number       // 2000ms (2 seconds)
    longSegmentThresholdMs: number  // 2000ms (2 seconds)
  }
  output: {
    includeScreenshots: boolean  // false
    prettyPrintJson: boolean    // true
  }
  userPreferences: {
    startUrl: string
    outputPath: string
  }
  audio: {
    selectedMicrophoneId?: string
  }
}
```

**Location:**
- macOS: `~/Library/Application Support/dodo-recorder/settings.json`
- Windows: `%USERPROFILE%\AppData\Roaming\dodo-recorder\settings.json`

**IPC Access:**
```typescript
// Get all settings
ipcMain.handle('settings-get-all', async () => {
  return settingsStore.getAll()
})

// Update settings
ipcMain.handle('settings-update', async (event, updates) => {
  return settingsStore.update(updates)
})
```

**Why Persistent Settings:**
- User doesn't need to re-enter URL/path each session
- Voice distribution preferences saved
- Audio device selection remembered
- User preferences maintained across app restarts

---

## Key Features & Their Current State

### âœ… Implemented Features

#### 1. Browser Recording
**Status:** Production-ready

**Capabilities:**
- Launch Chromium browser via Playwright
- Record clicks, fills, navigation, keypresses, selects, checks, scrolls
- Capture rich locator information (testId, id, role, text, CSS, XPath)
- Multiple locator strategies with confidence levels
- Real-time action display in UI

**Action Types:** `click`, `fill`, `navigate`, `keypress`, `select`, `check`, `scroll`, `assert`, `screenshot`

**Implementation:** `electron/browser/recorder.ts`

---

#### 2. Voice Recording & Transcription
**Status:** Production-ready

**Capabilities:**
- Capture audio via Web Audio API (MediaRecorder)
- WebM format, 16kHz, mono (Whisper native)
- Local transcription via Whisper.cpp (small.en model)
- Optimized early speech detection
- Anti-hallucination filtering

**Performance:**
- ~2-3x real-time (10s audio â†’ 3-5s transcription)
- ~95% hallucination detection accuracy

**Implementation:** `electron/audio/transcriber.ts`

---

#### 3. Voice-to-Action Distribution
**Status:** Production-ready

**Capabilities:**
- 4s lookback window (speech precedes action)
- 2s lookahead window (confirmations)
- Long segment handling (>2s spans multiple actions)
- Closest-action fallback
- Overlap handling

**Configuration:**
- User-adjustable via settings
- Defaults: lookback=4000ms, lookahead=2000ms, threshold=2000ms

**Implementation:** `electron/utils/voiceDistribution.ts`

---

#### 4. Sentence-Level Narrative Generation
**Status:** Production-ready

**Capabilities:**
- Split voice into sentences with proportional timestamps
- Interleave action references within sentences
- Actions appear at most relevant locations
- Natural reading flow for AI
- Handles silent actions

**Improvement over segment-level:**
- 3-5x finer granularity
- Better context for AI interpretation
- More intuitive narrative flow

**Implementation:** `electron/utils/enhancedTranscript.ts`

---

#### 5. Browser Recording Widget
**Status:** Production-ready

**Capabilities:**
- Floating UI in recorded browser (top-right by default)
- Pause/resume recording
- Screenshot capture button
- Assertion mode toggle
- Voice recording indicator
- Draggable with edge snapping
- Shadow DOM isolation (never recorded)

**Keyboard Shortcuts:**
- Cmd/Ctrl+Shift+S: Screenshot
- Cmd/Ctrl+Click: Record assertion

**Implementation:** `electron/browser/recording-widget.ts`

---

#### 6. Assertion Mode with Hover Highlighting
**Status:** Production-ready

**Capabilities:**
- Visual feedback when hovering over elements
- Blue overlay with solid border
- Selector label showing best locator
- Dual trigger: widget button OR Cmd/Ctrl key
- Shadow DOM isolation

**Selector Priority:**
1. `[data-testid="..."]`
2. `#id`
3. `tagName[role="..."]`
4. `input[type="..."]`
5. `[name="..."]`
6. `tagName:text("...")` (buttons/links)
7. `tagName` (fallback)

**Performance:** 60 FPS, <5% CPU, <5MB memory

**Implementation:** `electron/browser/hover-highlighter.ts`

---

#### 7. Pause/Resume Recording
**Status:** Production-ready

**Capabilities:**
- Pause and resume from browser widget only
- Full state synchronization
- Audio pauses during pause
- Screenshot/assertion buttons disabled while paused
- Timer excludes paused duration

**Behavior When Paused:**
- All action recording stops
- Audio recording pauses
- Elapsed timer freezes
- Voice indicator hides

**Behavior When Resumed:**
- Recording continues from pause moment
- Audio resumes seamlessly
- Timeline remains synchronized

**Implementation:**
- Browser widget pause button: `electron/browser/recorder-widget.ts`
- Pause/resume IPC handlers: `electron/ipc/recording.ts`

---

#### 8. Session Output (Bundle Generation)
**Status:** Production-ready

**Output Format:**
```
session-YYYY-MM-DD-HHMMSS/
â”œâ”€â”€ INSTRUCTIONS.md    # Reusable AI instructions (~2,000 tokens)
â”œâ”€â”€ actions.json       # ~3,850 tokens per session
â””â”€â”€ screenshots/       # PNG files
```

**Actions.json Structure:**
```json
{
  "_meta": {
    "formatVersion": "2.0",
    "generatedBy": "Dodo Recorder",
    "sessionId": "session-2026-01-23-102150",
    "startTime": 1737628910000,
    "startTimeISO": "2026-01-23T10:21:50.000Z",
    "duration": "8s",
    "startUrl": "https://github.com/pricing",
    "totalActions": 10,
    "actionTypes": { "assert": 4, "screenshot": 2, "click": 1, "navigate": 3 }
  },
  "narrative": {
    "text": "This is the recording... [action:c8d39f77:assert] [action:aa42301c:assert]...",
    "note": "Voice commentary with embedded action references."
  },
  "actions": [...]
}
```

**Action Reference Format:**
- `[action:SHORT_ID:TYPE]` where SHORT_ID = first 8 chars of UUID
- Example: `[action:8c61934e:click]` â†’ `"id": "8c61934e-4cd3-4793-bdb5-5c1c6d696f37"`

**Implementation:** `electron/session/writer.ts`

---

#### 9. Transcript View
**Status:** Production-ready

**Capabilities:**
- Displays voice commentary with embedded action references
- Parse `[action:SHORT_ID:TYPE]` and `[screenshot:FILENAME]` references
- Clickable action badges that highlight corresponding action in ActionsList
- Smooth scroll to highlighted action
- Split-pane layout with ActionsList (50/50)
- Natural reading flow with sentence-level action placement

**Implementation:** `src/components/TranscriptView.tsx`

---

#### 10. Settings Management
**Status:** Production-ready

**Capabilities:**
- Persistent JSON storage
- Start URL and output path caching
- Voice recording toggle
- Microphone selector
- Voice distribution window settings
- Output format options (screenshots, pretty print)

**Implementation:** 
- Store: `electron/settings/store.ts`
- UI: `src/components/SettingsPanel.tsx`
- Hook: `src/lib/useSettings.ts`

---

#### 11. Microphone Selection & Fallback
**Status:** Production-ready

**Capabilities:**
- Enumerate audio devices
- Select specific microphone
- Fallback to default if selected device unavailable
- Real-time audio level meter

**Fallback Logic:**
```typescript
if (selectedMicrophoneId) {
  const devices = await navigator.mediaDevices.enumerateDevices()
  const deviceExists = devices.some(d => d.deviceId === selectedMicrophoneId)
  
  if (!deviceExists) {
    // Selected device not available â†’ use default
    setAudioError('Selected microphone not available, using default')
    setSelectedMicrophoneId(undefined)
  }
}
```

**Implementation:** `src/components/MicrophoneSelector.tsx`

---

#### 12. Logging & Debugging
**Status:** Production-ready

**Capabilities:**
- Production logging via electron-log
- Automatic file logging to OS locations
- Log rotation (10MB per file)
- Multiple log levels (debug, info, warn, error)
- In-app "View Logs" and "Open Log Folder" buttons
- Build info display (commit hash, branch, build time)

**Log Locations:**
- macOS: `~/Library/Logs/dodo-recorder/main.log`
- Windows: `%USERPROFILE%\AppData\Roaming\dodo-recorder\logs\main.log`

**Log Levels by Environment:**
- Development: Console (debug) + File (debug)
- Production: Console (error only) + File (info and above)

**Implementation:** `electron/utils/logger.ts`

---

### ğŸš§ Partially Implemented / Known Issues

#### 1. Audio Volume Monitoring
**Status:** Not implemented (TODO item)

**Issue:**
- No real-time monitoring of audio input volume during recording
- Cannot warn user if microphone is too quiet or silent

**Planned Behavior:**
- Listen to audio stream during recording
- Check if volume exceeds threshold
- Warn user if no/little sound detected
- Skip transcription if audio was too poor

**Implementation Location:** `src/components/RecordingControls.tsx` (audio capture logic)

---

#### 2. Pause + Stop Crash
**Status:** Known bug (TODO item)

**Issue:**
- When recording is paused in browser widget and user clicks "Stop" in app UI, process crashes

**Likely Cause:**
- Race condition between pause and stop operations
- State mismatch between browser widget and main process
- Audio cleanup issues when stopping while paused

**Implementation Location:** 
- `electron/ipc/recording.ts` (stop-recording handler)
- `electron/browser/recorder.ts` (stop method)

---

#### 3. DOM Freezing
**Status:** Not implemented (TODO item)

**Proposed Feature:**
- Ability to freeze DOM during recording
- Useful when waiting for loading states
- User can freeze DOM, then assert/click elements
- Option to refresh/unfreeze DOM

**Use Case:**
- Element appears briefly during loading
- User freezes DOM at right moment
- Assert or click element
- Resume normal DOM behavior

**Implementation Location:** 
- `electron/browser/recorder.ts` (add exposeFunction for DOM freezing)
- `electron/browser/recording-widget.ts` (add freeze button)

---

#### 4. Widget Rendering Issues
**Status:** Known bug (TODO item)

**Issue:**
- Sometimes widget doesn't render on certain websites
- Appears to depend on initially loaded parent HTML
- Example: youtube.com is problematic

**Likely Cause:**
- Timing issues with script injection
- Shadow DOM conflicts with page styles
- CSP (Content Security Policy) blocking

**Implementation Location:** 
- `electron/browser/recorder.ts` (script injection timing)
- `electron/browser/recording-widget.ts` (widget initialization)

---

#### 5. Dev Mode Window Popping to Top
**Status:** Known issue (TODO item)

**Issue:**
- Electron app pops on top of all other windows when files change in dev mode
- Live reload causes window to grab focus

**Likely Cause:**
- Vite HMR (Hot Module Replacement) triggers window focus
- Electron's behavior when reloaded content changes

**Desired Behavior:**
- Keep live reload for development
- Window should not pop to top on reload

**Implementation Location:** 
- `vite.config.ts` (Vite HMR configuration)
- `electron/main.ts` (window focus management)

---

## Data Flow & Recording Lifecycle

### Complete Recording Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    START RECORDING                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. User fills settings in UI                              â”‚
â”‚    - Start URL                                             â”‚
â”‚    - Output path                                           â”‚
â”‚    - Voice toggle (enabled)                                 â”‚
â”‚    - Microphone selection (if voice enabled)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. User clicks "Start Recording" button                   â”‚
â”‚    - URL and path validated                               â”‚
â”‚    - Microphone permission requested (if voice enabled)       â”‚
â”‚    - Selected device validated                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. Renderer process calls IPC handler                    â”‚
â”‚    window.electronAPI.startRecording(url, outputPath, start)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. Main process creates BrowserRecorder                   â”‚
â”‚    - Launches Playwright Chromium browser                  â”‚
â”‚    - Injects tracking scripts before page load             â”‚
â”‚    - Navigates to start URL                             â”‚
â”‚    - Starts emitting action events                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. Renderer starts audio recording (if voice enabled)    â”‚
â”‚    - MediaRecorder captures chunks                        â”‚
â”‚    - Chunks stored in memory                            â”‚
â”‚    - Audio activity sent to browser widget                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 6. User interacts with browser                          â”‚
â”‚    - Clicks, fills, navigates                          â”‚
â”‚    - Injected script captures events                     â”‚
â”‚    - Actions sent to main process via IPC                â”‚
â”‚    - Actions forwarded to renderer for display           â”‚
â”‚    - Voice commentary captured continuously                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 7. (Optional) User pauses/resumes via browser widget    â”‚
â”‚    - Recording stops temporarily                         â”‚
â”‚    - Audio pauses                                       â”‚
â”‚    - Timer freezes                                     â”‚
â”‚    - Resume continues seamlessly                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 8. User clicks "Stop Recording" button                 â”‚
â”‚    - Browser recording stops, closes browser             â”‚
â”‚    - Audio recording stops                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 9. Renderer transcribes audio (if voice enabled)         â”‚
â”‚    window.electronAPI.transcribeAudio(audioBuffer)        â”‚
â”‚    - FFmpeg converts WebM â†’ WAV + padding             â”‚
â”‚    - Whisper.cpp transcribes to JSON                    â”‚
â”‚    - Timestamps adjusted for padding                   â”‚
â”‚    - Hallucinations filtered                         â”‚
â”‚    â†’ Returns TranscriptSegment[]                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 10. Renderer distributes voice to actions                 â”‚
â”‚     window.electronAPI.distributeVoiceSegments(actions)    â”‚
â”‚     - Temporal proximity matching (4s/2s windows)      â”‚
â”‚     - Long segment handling                             â”‚
â”‚     - Closest-action fallback                           â”‚
â”‚     â†’ Returns actions with voiceSegments attached        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 11. Renderer generates transcript                       â”‚
â”‚     window.electronAPI.generateTranscriptWithReferences()  â”‚
â”‚     - Split voice into sentences with timestamps          â”‚
â”‚     - Interleave actions within sentences               â”‚
â”‚     - Build narrative with embedded [action:ID:TYPE]   â”‚
â”‚     â†’ Returns transcript text                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 12. Store updated with transcript and voice-enhanced actionsâ”‚
â”‚     - transcriptText set in store                      â”‚
â”‚     - actions array updated with voiceSegments           â”‚
â”‚     - "View transcript" button becomes visible         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 13. (Optional) User views transcript                   â”‚
â”‚     - Split view shows ActionsList + TranscriptView      â”‚
â”‚     - Click action badges to highlight in ActionsList    â”‚
â”‚     - Smooth scroll to highlighted action               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 14. User clicks "Save Session" button                  â”‚
â”‚     window.electronAPI.saveSession(bundle)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 15. Main process saves session bundle                   â”‚
â”‚     - Create session directory (session-YYYY-MM-DD-HHMMSS)â”‚
â”‚     - Ensure INSTRUCTIONS.md exists (write if needed)    â”‚
â”‚     - Generate narrative from actions                   â”‚
â”‚     - Write actions.json (_meta + narrative + actions)  â”‚
â”‚     - Copy screenshots to screenshots/ folder            â”‚
â”‚     â†’ Return session directory path                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 16. UI shows success state                              â”‚
â”‚     - "Session saved" message                          â”‚
â”‚     - "Save" button disabled (green checkmark)          â”‚
â”‚     - "Reset" button enabled                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Pause/Resume Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User clicks pause button in browser widget               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Widget calls window.__dodoPauseRecording()               â”‚
â”‚    - Exposed function from recorder                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Recorder sets paused state                              â”‚
â”‚    - Sets window.__dodoRecordingPaused = true           â”‚
â”‚    - Notifies widget via page.evaluate()               â”‚
â”‚    - Records pause timestamp                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Widget updates UI                                      â”‚
â”‚    - Pause button â†’ resume button                       â”‚
â”‚    - Screenshot button disabled                         â”‚
â”‚    - Assertion button disabled                          â”‚
â”‚    - Voice indicator hides                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Renderer updates display                                â”‚
â”‚    - Shows "Recording paused" message                   â”‚
â”‚    - Status shows "Paused" (yellow)                    â”‚
â”‚    - Timer stops counting                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Injected script stops recording events                   â”‚
â”‚    - Clicks not recorded                              â”‚
â”‚    - Fills not recorded                               â”‚
â”‚    - All event handlers check paused state first         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Audio recording pauses (if voice enabled)                â”‚
â”‚    - MediaRecorder pauses                               â”‚
â”‚    - No audio chunks collected during pause             â”‚
â”‚    - Audio activity indicator off                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User clicks resume button in browser widget              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Widget calls window.__dodoResumeRecording()              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Recorder resumes recording                             â”‚
â”‚    - Sets window.__dodoRecordingPaused = false          â”‚
â”‚    - Notifies widget via page.evaluate()               â”‚
â”‚    - Calculates paused duration                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Widget updates UI                                      â”‚
â”‚    - Resume button â†’ pause button                       â”‚
â”‚    - Screenshot button enabled                          â”‚
â”‚    - Assertion button enabled                           â”‚
â”‚    - Voice indicator shows (if voice enabled)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Renderer updates display                                â”‚
â”‚    - Status shows "Recording" (red pulsing)           â”‚
â”‚    - Timer resumes (paused duration excluded)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Injected script resumes recording events                 â”‚
â”‚    - All event handlers check paused state               â”‚
â”‚    - Recording continues seamlessly                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Audio recording resumes (if voice enabled)               â”‚
â”‚    - MediaRecorder resumes                              â”‚
â”‚    - Audio chunks collected again                       â”‚
â”‚    - Audio activity indicator on                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### IPC Communication Flow

**Start Recording:**
```
Renderer (RecordingControls.tsx)
  â†“ window.electronAPI.startRecording(url, outputPath, startTime)
Main (ipc/recording.ts)
  â†“ Validates input, creates BrowserRecorder
Main (recorder.ts)
  â†“ Launches browser, injects scripts, navigates
Main â†’ Renderer (webContents.send)
  â†“ 'action-recorded' events for each action
Renderer (ActionsList.tsx)
  â†“ Updates UI in real-time
```

**Stop & Transcribe:**
```
Renderer
  â†“ window.electronAPI.stopRecording()
Main (ipc/recording.ts)
  â†“ Stops browser, returns actions
Renderer
  â†“ window.electronAPI.transcribeAudio(buffer)
Main (audio/transcriber.ts)
  â†“ FFmpeg + Whisper.cpp + filtering
Main â†’ Renderer
  â†“ Returns TranscriptSegment[]
Renderer
  â†“ window.electronAPI.distributeVoiceSegments(actions, segments)
Main (voiceDistribution.ts)
  â†“ Temporal proximity matching
Main â†’ Renderer
  â†“ Returns actions with voiceSegments
Renderer
  â†“ window.electronAPI.generateTranscriptWithReferences(actions)
Main (enhancedTranscript.ts)
  â†“ Sentence-level narrative generation
Main â†’ Renderer
  â†“ Returns transcript text
Renderer (store)
  â†“ Updates transcriptText and actions
```

**Save Session:**
```
Renderer
  â†“ window.electronAPI.saveSession(bundle)
Main (session/writer.ts)
  â†“ Creates directory, writes files
Main â†’ Renderer
  â†“ Returns session directory path
Renderer
  â†“ Shows success state
```

---

## Voice Transcription Pipeline

### Why Whisper.cpp?

**Options Considered:**
1. OpenAI Whisper API
2. whisper-node (Python wrapper)
3. whisper.cpp (C++ port)

**Why whisper.cpp Won:**

| Criteria | OpenAI API | whisper-node | **whisper.cpp** |
|----------|-------------|--------------|----------------|
| Privacy | No (cloud) | Yes | **Yes** |
| Costs | Yes | No | **No** |
| Performance | Fast | Slow | **Fast** |
| Dependencies | API key | Python | **None** |
| Bundling | Easy | Hard | **Easy** |
| Offline | No | Yes | **Yes** |

**Whisper.cpp Benefits:**
- Uses OpenAI's Whisper model (same weights, same accuracy)
- Runs 100% locally
- Faster than Python (~2-3x real-time)
- No runtime dependencies
- Easy to bundle (static binary)
- Free after model download

### Transcription Pipeline Detailed

#### Stage 1: Audio Capture

```typescript
// In RecordingControls.tsx
const stream = await navigator.mediaDevices.getUserMedia({
  audio: {
    deviceId: selectedMicrophoneId ? { exact: selectedMicrophoneId } : undefined,
    echoCancellation: true,
    noiseSuppression: true,
    autoGainControl: true,
    sampleRate: 16000  // Whisper native
  }
})

const mediaRecorder = new MediaRecorder(stream, {
  mimeType: 'audio/webm;codecs=opus'
})

mediaRecorder.ondataavailable = (event) => {
  if (event.data.size > 0) {
    audioChunks.push(event.data)
  }
}

mediaRecorder.start(1000)  // Collect chunks every second
```

**Why WebM + Opus:**
- Native browser format
- Efficient compression
- 16kHz sample rate matches Whisper
- Easy to convert to WAV

---

#### Stage 2: FFmpeg Conversion

```typescript
// In transcriber.ts
ffmpeg(inputPath)
  .audioFrequency(16000)      // 16kHz sample rate
  .audioChannels(1)            // Mono
  .audioCodec('pcm_s16le')     // PCM format
  .format('wav')
  .audioFilters([
    'apad=pad_dur=1.5',       // Pad end with 1.5s silence
    'areverse',                // Reverse
    'apad=pad_dur=1.5',       // Pad beginning with 1.5s silence
    'areverse'                 // Reverse back
  ])
  .save(outputPath)
```

**Why 1.5s Padding:**
- Whisper's VAD (Voice Activity Detection) misses early speech
- Padding ensures first words are detected
- We subtract 1500ms from timestamps later

**Why Reverse-Reverse:**
- `apad` only pads end
- Reverse â†’ pad â†’ reverse back pads beginning
- Clean way to add leading silence

---

#### Stage 3: Whisper.cpp Execution

```typescript
const command = [
  whisperMainPath,              // Path to binary
  '-m', modelPath,            // Path to ggml-small.en.bin
  '-f', audioPath,            // Input WAV file
  '-l', 'en',                // English language
  '-oj',                      // Output JSON format
  '-ml', '50',                // Max 50 chars per segment
  '-sow',                     // Split on word boundaries
  '-bo', '5',                 // Best of 5 candidates
  '-bs', '5',                 // Beam size 5
  '-et', '2.0',               // Entropy threshold (critical!)
  '-lpt', '-1.0',            // Log probability threshold
  '--prompt', '"This is a recording session with browser interactions, clicking, navigation, and voice commentary."'
].join(' ')
```

**Critical Parameters:**

| Parameter | Value | Why |
|-----------|-------|-----|
| `-et` | 2.0 | Lower = more aggressive early speech detection |
| `-bo` | 5 | Beam search breadth, higher = better quality |
| `-bs` | 5 | Beam size, matches beam search |
| `-ml` | 50 | Phrase-level segments (not word-by-word) |
| `--prompt` | Context | Prime with expected vocabulary (browser, clicking, etc.) |

**Entropy Threshold (et):**
- Whisper waits for certainty before emitting segments
- Default is too high â†’ misses early speech
- 2.0 = aggressive, catches early words reliably

---

#### Stage 4: JSON Parsing

```typescript
// Whisper output format (JSON)
interface WhisperOutput {
  segments: Array<{
    id: number
    start: number        // Seconds
    end: number          // Seconds
    text: string
  }>
}

// Parse JSON
const output = JSON.parse(stdout)

// Convert to our format
const segments: TranscriptSegment[] = output.segments.map(seg => ({
  id: `t${seg.id}`,
  startTime: Math.round((seg.start - 1.5) * 1000),  // Subtract padding!
  endTime: Math.round((seg.end - 1.5) * 1000),
  text: seg.text.trim()
}))
```

**Timestamp Adjustment:**
- We added 1.5s padding to beginning
- Whisper timestamps include padding
- Subtract 1500ms to get correct session-relative timestamps

---

#### Stage 5: Post-Processing (Anti-Hallucination)

```typescript
// Detect repetitive text
const textCounts = new Map<string, number>()
result.forEach(segment => {
  const text = segment.speech.trim()
  textCounts.set(text, (textCounts.get(text) || 0) + 1)
})

const hallucinatedTexts = new Set<string>()
textCounts.forEach((count, text) => {
  if (count >= 2) {
    hallucinatedTexts.add(text)
  }
})

// Filter
const validSegments = result.filter(segment => {
  const text = segment.speech.trim()
  const isValid = text.length > 0 &&
    text !== WHISPER_PROMPT &&           // Remove prompt hallucination
    !hallucinatedTexts.has(text) &&     // Remove repetitions
    !text.match(/^\[.*\]$/) &&          // Remove [BLANK_AUDIO], [noise]
    !text.match(/^\(.*\)$/) &&          // Remove (mouse clicking)
    text.length > 2                     // Minimum 3 chars
  return isValid
})
```

**Filters Explained:**

| Filter | Example | Why |
|--------|---------|------|
| Prompt text | "This is a recording session..." | Whisper repeats prompt in silence |
| Repetitions | "..." (appears 2+ times) | Hallucination marker |
| Brackets | `[BLANK_AUDIO]`, `[noise]` | Non-speech markers |
| Parentheses | `(mouse clicking)` | Ambient sounds |
| Short text | ".", "a" | Too short to be useful |

**Effectiveness:** ~95% of hallucinations removed

---

#### Stage 6: Voice Distribution (to Actions)

See [Voice Distribution](#5-voice-distribution-electronutilsvoicedistributionts) section above.

---

#### Stage 7: Narrative Generation (Sentence-Level)

See [Narrative Builder](#6-narrative-builder-sharednarrativebuilderts--electronutilsenhancedtranscriptts) section above.

---

### Performance Characteristics

**Transcription Speed:**
- small.en model: ~2-3x real-time
- Example: 60s audio â†’ 20-30s transcription

**Memory Usage:**
- Idle: ~200 MB
- Recording: +100 MB
- Transcribing: +1.0 GB (model loaded)
- Peak: ~1.5 GB

**Quality:**
- Early speech detection: Reliable with optimized parameters
- Technical terms: Good (small.en better than base.en)
- Hallucinations: ~95% filtered

---

## Session Output Format

### Design Philosophy

**Goals:**
1. **Token-efficient** - Minimize tokens sent to AI
2. **Self-documenting** - All instructions embedded
3. **Human-readable** - Engineers can understand sessions
4. **Framework-agnostic** - Works with any testing framework
5. **AI-ready** - Optimized for LLM consumption

### Bundle Structure

```
session-YYYY-MM-DD-HHMMSS/
â”œâ”€â”€ INSTRUCTIONS.md    # ~2,000 tokens (reusable)
â”œâ”€â”€ actions.json       # ~3,850 tokens per session
â””â”€â”€ screenshots/       # PNG files
```

**Token Efficiency:**
- 1 session: ~5,850 tokens
- 5 sessions: ~21,250 tokens (INSTRUCTIONS.md once + 5Ã— actions.json)
- 10 sessions: ~40,500 tokens (INSTRUCTIONS.md once + 10Ã— actions.json)

### INSTRUCTIONS.md

**Purpose:** Reusable AI instructions read once per output directory

**Sections:**
1. Overview - What are session bundles
2. Bundle structure - Files and purposes
3. Processing instructions:
   - Read actions.json
   - Parse action references (`[action:SHORT_ID:TYPE]`)
   - Choose locator strategies (confidence-based)
   - Interpret action types
   - Use voice commentary
4. Framework-specific implementation:
   - Detecting framework (Playwright/Cypress)
   - Playwright guide (structure, locators, best practices)
   - Cypress guide (structure, locators, best practices)
   - Empty repository handling
5. Format version

**Example Content:**
```markdown
# AI Instructions for Dodo Recorder Sessions

## Overview
Session bundles contain recorded browser interactions with voice commentary.

## Processing Instructions
1. Read actions.json
2. Parse narrative for user intent
3. Match action references: `[action:SHORT_ID:TYPE]` â†’ actions array
4. Choose locators by confidence (high > medium > low)
5. Generate framework-specific test code

## Framework Detection
Check for:
- `playwright.config.ts` or `playwright.config.js`
- `cypress.config.ts` or `cypress.config.js`
- `package.json` dependencies

## Playwright Guide
```typescript
test('example', async ({ page }) => {
  await page.goto('https://example.com')
  await page.getByRole('button', { name: 'Submit' }).click()
})
```

## Locator Priority
1. testId (highest confidence)
2. role
3. placeholder
4. text
5. css (lowest confidence)
```

---

### actions.json

**Structure:**

```typescript
interface ActionsJson {
  _meta: SessionMetadata
  narrative: {
    text: string
    note: string
  }
  actions: RecordedAction[]
}

interface SessionMetadata {
  formatVersion: "2.0"
  generatedBy: string
  sessionId: string           // session-YYYY-MM-DD-HHMMSS
  startTime: number            // Unix timestamp ms
  startTimeISO: string         // ISO 8601
  duration: string             // e.g., "3m 45s"
  startUrl?: string
  totalActions: number
  actionTypes: Record<string, number>  // { "click": 5, "fill": 2 }
}

interface RecordedAction {
  id: string                 // UUID
  timestamp: number          // ms from session start
  type: ActionType           // click, fill, navigate, etc.
  target: {
    selector: string
    locators: Array<{
      strategy: string        // testId, role, text, css, xpath
      value: string
      confidence: string    // high, medium, low
    }>
    role?: string
    name?: string
    testId?: string
    text?: string
    tagName?: string
    boundingBox?: {
      x: number
      y: number
      width: number
      height: number
    }
  }
  value?: string             // For fill actions
  screenshot?: string         // Filename
}
```

**Example:**

```json
{
  "_meta": {
    "formatVersion": "2.0",
    "generatedBy": "Dodo Recorder",
    "sessionId": "session-2026-01-23-102150",
    "startTime": 1737628910000,
    "startTimeISO": "2026-01-23T10:21:50.000Z",
    "duration": "8s",
    "startUrl": "https://github.com/pricing",
    "totalActions": 10,
    "actionTypes": {
      "assert": 4,
      "screenshot": 2,
      "click": 1,
      "navigate": 3
    }
  },
  "narrative": {
    "text": "Navigating to GitHub pricing page [action:e6c3069a:navigate]. Now I'm going to assert all the pricing plans [action:c5922be3:assert] [action:72e42724:assert] [action:2e185707:assert] [action:4a62c1b8:assert]. Taking a screenshot [action:ef955889:screenshot].",
    "note": "Voice commentary with embedded action references. Match SHORT_ID (first 8 chars) with action.id in actions array."
  },
  "actions": [
    {
      "id": "e6c3069a-1b2c-4d5e-6f7g-8h9i0j1k2l3m",
      "timestamp": 0,
      "type": "navigate",
      "target": {
        "selector": "https://github.com/pricing",
        "locators": [
          {
            "strategy": "url",
            "value": "https://github.com/pricing",
            "confidence": "high"
          }
        ]
      }
    },
    {
      "id": "c5922be3-4cd3-4793-bdb5-5c1c6d696f37",
      "timestamp": 2500,
      "type": "assert",
      "target": {
        "selector": "getByText('\\bFree\\b')",
        "locators": [
          {
            "strategy": "text",
            "value": "getByText('\\bFree\\b')",
            "confidence": "medium"
          },
          {
            "strategy": "css",
            "value": "div:nth-of-type(1) h2",
            "confidence": "low"
          }
        ],
        "role": "heading",
        "name": "Free",
        "tagName": "H2",
        "text": "Free",
        "boundingBox": {
          "x": 100,
          "y": 200,
          "width": 300,
          "height": 50
        }
      }
    }
  ]
}
```

---

### screenshots/

**Format:** PNG files

**Naming:** `screenshot-{timestamp}.png`

**Referenced by:**
- `action.screenshot` field
- `[screenshot:filename.png]` in narrative

**Example:**
```
session-2026-01-23-102150/
â””â”€â”€ screenshots/
    â”œâ”€â”€ screenshot-0000.png
    â”œâ”€â”€ screenshot-2500.png
    â””â”€â”€ screenshot-5000.png
```

---

## Browser Recording & Widget System

### Recording Architecture

**Three-Layer Injection:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 1: Injected Script (event capture)               â”‚
â”‚  electron/browser/injected-script.ts                      â”‚
â”‚  - DOM event listeners (click, input, keypress, etc.)     â”‚
â”‚  - Rich locator extraction                                â”‚
â”‚  - Calls window.__dodoRecordAction()                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 2: Recording Widget (UI controls)                 â”‚
â”‚  electron/browser/recording-widget.ts                    â”‚
â”‚  - Pause/resume, screenshot, assertion buttons            â”‚
â”‚  - Voice indicator                                      â”‚
â”‚  - Draggable with edge snapping                         â”‚
â”‚  - Shadow DOM isolation                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 3: Hover Highlighter (visual feedback)           â”‚
â”‚  electron/browser/hover-highlighter.ts                  â”‚
â”‚  - Blue overlay on hover (assertion mode)                â”‚
â”‚  - Selector label display                               â”‚
â”‚  - Shadow DOM isolation                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Injected Script (`injected-script.ts`)

**Purpose:** Capture all user interactions in the browser

**Events Captured:**
- `click` - Click interactions (filtered by assertion mode)
- `input` - Text input (debounced to avoid spam)
- `keydown` - Key presses (special keys only)
- `change` - Select dropdown changes
- `blur` - Input field blur events

**Locator Extraction:**

```typescript
function extractElementInfo(element: Element): TargetInfo {
  // Test ID (highest priority)
  const testId = element.getAttribute('data-testid')
  
  // ID
  const id = element.id
  
  // ARIA attributes
  const role = element.getAttribute('role')
  const ariaLabel = element.getAttribute('aria-label')
  const ariaLabelledby = element.getAttribute('aria-labelledby')
  
  // Form attributes
  const name = element.getAttribute('name')
  const type = element.getAttribute('type')
  const placeholder = element.getAttribute('placeholder')
  
  // Text content (buttons, links, labels)
  const text = element.textContent?.trim()
  
  // Tag name and class
  const tagName = element.tagName
  const className = element.className
  
  // Bounding box
  const rect = element.getBoundingClientRect()
  
  // CSS selector (fallback)
  const cssSelector = generateCssSelector(element)
  
  // XPath (fallback)
  const xpath = generateXPath(element)
  
  return {
    selector: chooseBestSelector(...),
    locators: [
      { strategy: 'testId', value: testId ? `[data-testid="${testId}"]` : null, confidence: 'high' },
      { strategy: 'id', value: id ? `#${id}` : null, confidence: 'high' },
      { strategy: 'role', value: role ? `getByRole('${role}', { name: '${ariaLabel || text}' })` : null, confidence: 'high' },
      { strategy: 'placeholder', value: placeholder ? `getByPlaceholder('${placeholder}')` : null, confidence: 'medium' },
      { strategy: 'text', value: text ? `getByText('${text}')` : null, confidence: 'medium' },
      { strategy: 'css', value: cssSelector, confidence: 'low' },
      { strategy: 'xpath', value: xpath, confidence: 'low' }
    ].filter(l => l.value !== null),
    role,
    name: ariaLabel,
    testId,
    text,
    tagName,
    boundingBox: {
      x: Math.round(rect.left),
      y: Math.round(rect.top),
      width: Math.round(rect.width),
      height: Math.round(rect.height)
    }
  }
}
```

**Why Multiple Locators:**
- Test IDs can change
- Framework migrations (different locator strategies)
- AI can choose best option based on confidence
- Fallbacks if primary locator fails

---

### Recording Widget (`recording-widget.ts`)

**Shadow DOM Isolation:**

```typescript
const widgetHost = document.createElement('div')
widgetHost.id = '__dodo-recorder-widget-host'
widgetHost.style.cssText = 'position: fixed; z-index: 2147483647; pointer-events: none;'
widgetHost.setAttribute('data-dodo-recorder', 'true')  // Mark as non-React element

const shadow = widgetHost.attachShadow({ mode: 'closed' })
```

**Benefits:**
- Complete CSS isolation (page styles don't affect widget)
- Page JavaScript can't manipulate widget
- Event handlers see widget as separate context

**Features:**

1. **Pause/Resume Button:**
   - Toggle between pause (â¸) and resume (â–¶) icons
   - Calls `window.__dodoPauseRecording()` / `window.__dodoResumeRecording()`

2. **Screenshot Button:**
   - Camera icon
   - Calls `window.__dodoTakeScreenshot()`
   - Disabled while paused

3. **Assertion Button:**
   - Eye icon, blue when active
   - Toggles `window.__dodoAssertionMode()` function
   - Disabled while paused

4. **Voice Recording Indicator:**
   - Red pulsing dot (10px)
   - Hidden while paused
   - Controlled by `window.__dodoAudioActive` (set by main process)

5. **Drag and Drop:**
   - Drag widget body to reposition
   - Edge snapping (top/right/bottom/left) on release
   - 20px padding from edges
   - Cubic-bezier animation (0.3s)

**Widget Exclusion from Recording:**

```typescript
const isWithinWidget = (target: Element): boolean => {
  const widgetHost = document.getElementById(WIDGET_HOST_ID)
  return !!(widgetHost && (widgetHost.contains(target) || widgetHost === target))
}

// All event listeners check before recording
document.addEventListener('click', (e) => {
  if (isWithinWidget(e.target as Element)) return
  // Record action...
})
```

---

### Hover Highlighter (`hover-highlighter.ts`)

**Dual Trigger Mode:**

```typescript
function isAssertionModeActive(): boolean {
  const widgetMode = win.__dodoAssertionMode?.() || false
  const keyMode = isCommandKeyPressed  // Cmd/Ctrl key
  return widgetMode || keyMode
}
```

**Visual Feedback:**

```typescript
// Blue overlay
overlay.style.cssText = `
  position: absolute;
  background: rgba(59, 130, 246, 0.2);
  border: 2px solid rgba(59, 130, 246, 0.8);
  pointer-events: none;
  transition: all 0.1s cubic-bezier(0.4, 0, 0.2, 1);
  display: none;
  border-radius: 2px;
`

// Selector label
label.style.cssText = `
  position: absolute;
  background: rgba(59, 130, 246, 0.95);
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 11px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  white-space: nowrap;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
`
```

**Selector Label Priority:**

```typescript
function getElementLabel(element: Element): string {
  const testId = element.getAttribute('data-testid')
  const id = element.id
  const role = element.getAttribute('role')
  const type = element.getAttribute('type')
  const name = element.getAttribute('name')
  
  if (testId) return `[data-testid="${testId}"]`
  if (id) return `#${id}`
  if (role) return `${element.tagName.toLowerCase()}[role="${role}"]`
  if (type && element.tagName === 'INPUT') return `input[type="${type}"]`
  if (name) return `[name="${name}"]`
  
  // Text for buttons/links
  if (element.tagName === 'BUTTON' || element.tagName === 'A') {
    const text = element.textContent?.trim().substring(0, 20)
    if (text) return `${element.tagName.toLowerCase()}:text("${text}")`
  }
  
  return element.tagName.toLowerCase()
}
```

**Performance Optimizations:**

1. **RAF Throttling:**
```typescript
let rafId: number | null = null

function scheduleUpdate(element: Element): void {
  if (rafId !== null) cancelAnimationFrame(rafId)
  rafId = requestAnimationFrame(() => {
    updateOverlay(element)
    rafId = null
  })
}
```

2. **Passive Listeners:**
```typescript
document.addEventListener('mousemove', (e) => {
  // Handler
}, { passive: true })  // No blocking
```

3. **Target Caching:**
```typescript
if (target === currentTarget) return  // Skip if same element
currentTarget = target
```

**Performance Targets:**
- 60 FPS
- <5% CPU
- <5 MB memory
- <16ms update latency

---

## UI Architecture

### Component Hierarchy

```
App (src/App.tsx)
â”œâ”€â”€ TitleBar (custom window controls)
â”œâ”€â”€ Header
â”‚   â”œâ”€â”€ StatusBar (recording status, timer, action count)
â”‚   â””â”€â”€ DebugInfoWidget (build info, log access)
â””â”€â”€ Main (flex container)
    â”œâ”€â”€ Sidebar (320px fixed)
    â”‚   â”œâ”€â”€ SettingsPanel
    â”‚   â”‚   â”œâ”€â”€ Start URL input
    â”‚   â”‚   â”œâ”€â”€ Output folder selector
    â”‚   â”‚   â”œâ”€â”€ Voice recording toggle
    â”‚   â”‚   â””â”€â”€ Microphone selector
    â”‚   â””â”€â”€ RecordingControls
    â”‚       â”œâ”€â”€ Start button
    â”‚       â”œâ”€â”€ Stop button
    â”‚       â”œâ”€â”€ Save button
    â”‚       â”œâ”€â”€ Reset button
    â”‚       â””â”€â”€ Audio status display
    â””â”€â”€ Content Area (flex-1)
        â”œâ”€â”€ ActionsList (full or 50%)
        â””â”€â”€ TranscriptView (50%, optional)
```

---

### TitleBar (`src/components/TitleBar.tsx`)

**Purpose:** Custom window controls for frameless Electron window

**Implementation:**

```tsx
<div className="h-9 bg-card flex items-center justify-between select-none">
  {/* macOS: Native controls on left */}
  {isMacOS && (
    <div className="flex items-center gap-2 px-2">
      {/* Native macOS window controls */}
    </div>
  )}
  
  {/* Windows: Custom controls on right */}
  {!isMacOS && (
    <div className="flex items-center">
      <button onClick={minimizeWindow} className="title-bar-btn">
        <Minus className="w-4 h-4" />
      </button>
      <button onClick={toggleMaximizeWindow} className="title-bar-btn">
        <Square className="w-4 h-4" />
      </button>
      <button onClick={closeWindow} className="title-bar-btn hover:bg-red-500">
        <X className="w-4 h-4" />
      </button>
    </div>
  )}
  
  {/* App title (centered) */}
  <div className="absolute left-1/2 -translate-x-1/2 text-sm font-medium text-foreground">
    Dodo Recorder
  </div>
</div>
```

**Platform-Specific Behavior:**
- macOS: Left side native controls, center title
- Windows: Right side custom controls, center title

---

### Header (`App.tsx`)

**Components:**

1. **StatusBar:**
   - Recording status (idle/recording/paused/processing/saving)
   - Elapsed time (during recording)
   - Action count
   - Color-coded status dots

2. **DebugInfoWidget:**
   - Collapsible widget
   - Build info: commit hash, branch, build time, Node version
   - Log access: "View Logs" + "Open Log Folder" buttons

---

### SettingsPanel (`src/components/SettingsPanel.tsx`)

**Input Fields:**

1. **Start URL:**
```tsx
<Input
  placeholder="https://example.com"
  value={startUrl}
  onChange={(e) => handleStartUrlChange(e.target.value)}
  disabled={isDisabled}
  className="bg-background"
/>
```
Auto-saved to persistent settings via `useSettings` hook.

2. **Output Folder:**
```tsx
<div className="flex gap-2">
  <Input
    placeholder="Select a folder..."
    value={outputPath}
    readOnly
    disabled={isDisabled}
    className="bg-background flex-1"
  />
  <Button variant="secondary" size="icon" onClick={handleSelectFolder} disabled={isDisabled}>
    <Folder className="h-4 w-4" />
  </Button>
</div>
```
Opens native folder picker via IPC.

3. **Voice Recording Toggle:**
```tsx
<div className="flex items-center justify-between py-2">
  <div className="flex items-center gap-2">
    <Mic className="h-4 w-4 text-muted-foreground" />
    <span className="text-sm">Voice Recording</span>
  </div>
  <Switch
    checked={isVoiceEnabled}
    onCheckedChange={setVoiceEnabled}
    disabled={isDisabled}
  />
</div>
```

4. **Microphone Selector:**
```tsx
{isVoiceEnabled && (
  <div className="space-y-2">
    <label className="text-sm font-medium">Microphone</label>
    <div className="flex gap-2">
      <Select value={selectedMicrophoneId} onValueChange={handleMicrophoneChange}>
        <SelectTrigger>
          <SelectValue placeholder="Select microphone..." />
        </SelectTrigger>
        <SelectContent>
          {microphones.map(mic => (
            <SelectItem key={mic.deviceId} value={mic.deviceId}>
              {mic.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
      <Button variant="secondary" size="icon" onClick={handleRefreshMicrophones}>
        <RefreshCw className="h-4 w-4" />
      </Button>
    </div>
  </div>
)}
```

---

### RecordingControls (`src/components/RecordingControls.tsx`)

**Buttons:**

1. **Start Recording:**
   - Shown when: `status === 'idle' && actions.length === 0`
   - Enabled when: `startUrl && outputPath`
   - Validates inputs, requests permissions, starts recording

2. **Stop Recording:**
   - Shown when: `status === 'recording'` or `status === 'paused'`
   - Stops browser, audio, processes

3. **Save Session:**
   - Shown when: `status === 'idle' && actions.length > 0`
   - Writes bundle to disk
   - Shows success state, disables to prevent duplicates

4. **Reset:**
   - Shown when: `status === 'idle' && actions.length > 0`
   - Confirmation dialog if not saved
   - Clears actions, transcript, audio state

**Audio Status Display:**

- **Recording:** Red pulsing dot + "Recording audio" + duration
- **Processing:** Spinner + "Transcribing audio..." (amber)
- **Complete:** Segment count (emerald)
- **Error:** Error message + MicOff icon (red)

---

### ActionsList (`src/components/ActionsList.tsx`)

**Display:**

- Numbered index (01, 02, etc.)
- Type icon and color-coded badge
- Timestamp (MM:SS)
- Description text (truncated with tooltip)
- Expandable details (locators, confidence, bounding box, voice segments)
- Delete button (appears on hover when not recording)

**Color Coding:**

| Type | Color | Icon |
|------|--------|-------|
| click | Blue | MousePointer |
| fill | Green | Type |
| navigate | Purple | Navigation |
| keypress | Yellow | Keyboard |
| select | Orange | List |
| check | Orange | Check |
| scroll | Cyan | ArrowDown |
| assert | Pink | Eye |
| screenshot | Indigo | Camera |

**Highlighting:**

```tsx
className={cn(
  highlightedActionId === action.id
    ? 'bg-blue-500/20 border-l-4 border-l-blue-400'
    : 'hover:bg-card'
)}
```

Triggered by clicking action reference in transcript.

---

### TranscriptView (`src/components/TranscriptView.tsx`)

**Layout:** Split pane with ActionsList (50/50)

**Parsing:**

```typescript
// Extract narrative section
const extractNarrative = (text: string): string => {
  const match = text.match(/## Narrative\s*\n\s*([\s\S]*?)(?:\n\n## Action Reference|$)/)
  return match?.[1]?.trim() || text
}

// Parse into structured parts
const parseTranscript = (text: string): TranscriptPart[] => {
  const regex = /\[(action|screenshot):([^\]]+)\]/g
  const parts: TranscriptPart[] = []
  let lastIndex = 0
  let match
  
  while ((match = regex.exec(text)) !== null) {
    // Add text before match
    if (match.index > lastIndex) {
      parts.push({
        type: 'text',
        content: text.substring(lastIndex, match.index)
      })
    }
    
    // Add match
    const [full, type, value] = match
    if (type === 'action') {
      const [id, actionType] = value.split(':')
      parts.push({
        type: 'action',
        content: full,
        actionId: id,
        actionType: actionType as ActionType
      })
    } else if (type === 'screenshot') {
      parts.push({
        type: 'screenshot',
        content: full,
        screenshotFilename: value
      })
    }
    
    lastIndex = regex.lastIndex
  }
  
  // Add remaining text
  if (lastIndex < text.length) {
    parts.push({
      type: 'text',
      content: text.substring(lastIndex)
    })
  }
  
  return parts
}
```

**Action Highlighting:**

```typescript
const handleActionClick = (shortId: string) => {
  const action = actions.find(a => a.id.startsWith(shortId))
  if (action) {
    setHighlightedActionId(action.id)
    
    // Auto-scroll to action
    setTimeout(() => {
      const element = document.querySelector(`[data-action-id="${action.id}"]`)
      element?.scrollIntoView({ behavior: 'smooth', block: 'center' })
    }, 100)
  }
}
```

---

## State Management

### Zustand Store (`src/stores/recordingStore.ts`)

**Global State:**

```typescript
interface RecordingState {
  // Recording state
  status: RecordingStatus
  actions: RecordedAction[]
  transcriptSegments: TranscriptSegment[]
  transcriptText: string
  startTime: number | null
  
  // Settings
  startUrl: string
  outputPath: string
  notes: string
  isVoiceEnabled: boolean
  selectedMicrophoneId: string | undefined
  
  // Audio state
  audioStatus: AudioStatus
  audioChunksCount: number
  audioError: string | null
  
  // UI state
  sessionSaved: boolean
  isTranscriptViewOpen: boolean
  highlightedActionId: string | null
  
  // Actions
  setStatus: (status: RecordingStatus) => void
  addAction: (action: RecordedAction) => void
  deleteAction: (id: string) => void
  setTranscriptText: (text: string) => void
  // ... more actions
}

type RecordingStatus = 'idle' | 'recording' | 'paused' | 'processing' | 'saving'
type AudioStatus = 'idle' | 'recording' | 'processing' | 'complete' | 'error'
```

**Access Pattern (with useShallow for optimization):**

```typescript
const { 
  status, 
  actions, 
  setStatus 
} = useRecordingStore(
  useShallow((state) => ({
    status: state.status,
    actions: state.actions,
    setStatus: state.setStatus
  }))
)
```

**Why Zustand:**
- No boilerplate (unlike Redux)
- No context providers (unlike Context API)
- Efficient re-renders with selectors
- Simple and intuitive
- Perfect for Electron apps

---

## Settings & Persistence

### Settings Store (`electron/settings/store.ts`)

**Persistent JSON Storage:**

```typescript
interface AppSettings {
  whisper: {
    transcriptionTimeoutMs: number
  }
  voiceDistribution: {
    lookbackMs: number
    lookaheadMs: number
    longSegmentThresholdMs: number
  }
  output: {
    includeScreenshots: boolean
    prettyPrintJson: boolean
  }
  userPreferences: {
    startUrl: string
    outputPath: string
  }
  audio: {
    selectedMicrophoneId?: string
  }
}
```

**Default Settings:**

```typescript
const DEFAULT_SETTINGS: AppSettings = {
  whisper: {
    transcriptionTimeoutMs: 300000  // 5 minutes
  },
  voiceDistribution: {
    lookbackMs: 4000,
    lookaheadMs: 2000,
    longSegmentThresholdMs: 2000
  },
  output: {
    includeScreenshots: false,
    prettyPrintJson: true
  },
  userPreferences: {
    startUrl: '',
    outputPath: ''
  },
  audio: {
    selectedMicrophoneId: undefined
  }
}
```

**IPC Access:**

```typescript
// Get all settings
ipcMain.handle('settings-get-all', async () => {
  return settingsStore.getAll()
})

// Update settings (partial)
ipcMain.handle('settings-update', async (event, updates) => {
  return settingsStore.update(updates)
})

// Reset to defaults
ipcMain.handle('settings-reset', async () => {
  return settingsStore.reset()
})
```

---

### React Settings Hook (`src/lib/useSettings.ts`)

```typescript
export function useSettings() {
  const [preferences, setPreferences] = useState<UserPreferences>({
    startUrl: '',
    outputPath: ''
  })
  
  const [microphoneSettings, setMicrophoneSettings] = useState<MicrophoneSettings>({
    selectedMicrophoneId: undefined
  })
  
  // Load on mount
  useEffect(() => {
    const loadSettings = async () => {
      const result = await window.electronAPI.getUserPreferences()
      if (result.success) {
        setPreferences(result.data)
      }
      
      const micResult = await window.electronAPI.getMicrophoneSettings()
      if (micResult.success) {
        setMicrophoneSettings(micResult.data)
      }
    }
    
    loadSettings()
  }, [])
  
  // Update functions
  const updatePreferences = async (updates: Partial<UserPreferences>) => {
    const result = await window.electronAPI.updateUserPreferences(updates)
    if (result.success) {
      setPreferences(prev => ({ ...prev, ...updates }))
    }
  }
  
  const updateMicrophoneSettings = async (updates: Partial<MicrophoneSettings>) => {
    const result = await window.electronAPI.updateMicrophoneSettings(updates)
    if (result.success) {
      setMicrophoneSettings(prev => ({ ...prev, ...updates }))
    }
  }
  
  return {
    preferences,
    microphoneSettings,
    updatePreferences,
    updateMicrophoneSettings
  }
}
```

**Usage in Components:**

```tsx
const { 
  preferences: { startUrl, outputPath },
  updatePreferences 
} = useSettings()

const handleStartUrlChange = async (url: string) => {
  setStartUrl(url)
  await updatePreferences({ startUrl: url })
}
```

---

## Logging & Debugging

### Logger Utility (`electron/utils/logger.ts`)

**electron-log Integration:**

```typescript
import log from 'electron-log'

export const logger = {
  debug: (message: string, ...args: any[]) => {
    log.debug(message, ...args)
  },
  
  info: (message: string, ...args: any[]) => {
    log.info(message, ...args)
  },
  
  warn: (message: string, ...args: any[]) => {
    log.warn(message, ...args)
  },
  
  error: (message: string, error?: Error) => {
    log.error(message, error)
  },
  
  getLogPath: () => log.transports.file.getFile().path,
  
  openLogFile: () => {
    const logPath = log.transports.file.getFile().path
    shell.openPath(logPath)
  },
  
  openLogFolder: () => {
    const logPath = log.transports.file.getFile().path
    const folder = path.dirname(logPath)
    shell.openPath(folder)
  },
  
  logStartupInfo: () => {
    log.info('='.repeat(75))
    log.info('Dodo Recorder Starting')
    log.info('='.repeat(75))
    log.info('App Version:', app.getVersion())
    log.info('Electron:', process.versions.electron)
    log.info('Platform:', process.platform, process.arch)
    log.info('Environment:', isDev ? 'development' : 'production')
    log.info('Log File:', log.transports.file.getFile().path)
    log.info('='.repeat(75))
  }
}
```

**Log Levels by Environment:**

```typescript
if (isDev) {
  log.transports.console.level = 'debug'
  log.transports.file.level = 'debug'
} else {
  log.transports.console.level = 'error'  // Only errors to console
  log.transports.file.level = 'info'      // Info+ to file
}
```

---

### Log Locations

**macOS:**
```
~/Library/Logs/dodo-recorder/main.log
```

**Windows:**
```
%USERPROFILE%\AppData\Roaming\dodo-recorder\logs\main.log
```

**Log Format:**
```
[YYYY-MM-DD HH:MM:SS.mmm] [LEVEL] Message
```

**Example:**
```
[2026-01-16 11:30:15.234] [INFO] Dodo Recorder Starting
[2026-01-16 11:30:15.245] [INFO] App Version: 0.3.0
[2026-01-16 11:30:20.567] [INFO] ğŸ¬ startRecording() called
[2026-01-16 11:30:20.568] [INFO]   startUrl: https://example.com
[2026-01-16 11:30:20.569] [INFO]   outputPath: /Users/test/sessions
[2026-01-16 11:30:20.570] [INFO]   isVoiceEnabled: true
[2026-01-16 11:30:20.571] [INFO] ğŸ¤ Microphone permission result: {"granted":true}
[2026-01-16 11:30:20.572] [INFO] âœ… Recording started successfully
```

---

### In-App Log Access

**StatusBar Component:**

```tsx
<Button variant="ghost" size="icon" onClick={handleViewLogs}>
  <FileText className="h-4 w-4" />
</Button>
<Button variant="ghost" size="icon" onClick={handleOpenLogFolder}>
  <FolderOpen className="h-4 w-4" />
</Button>
```

**Handlers:**

```typescript
const handleViewLogs = async () => {
  await window.electronAPI.openLogFile()
}

const handleOpenLogFolder = async () => {
  await window.electronAPI.openLogFolder()
}
```

**IPC Expose:**

```typescript
// In preload.ts
const electronAPI = {
  openLogFile: () => ipcRenderer.invoke('open-log-file'),
  openLogFolder: () => ipcRenderer.invoke('open-log-folder')
}

// In handlers.ts
ipcMain.handle('open-log-file', async () => {
  logger.openLogFile()
})

ipcMain.handle('open-log-folder', async () => {
  logger.openLogFolder()
})
```

---

### DevTools Console (Renderer)

**Access:**
- macOS: `Cmd+Option+I`
- Windows: `Ctrl+Shift+I`

**Renderer Logs:**
```typescript
console.log('ğŸ¬ startRecording() called')
console.error('âŒ Failed to start recording:', error)
console.warn('âš ï¸ Microphone permission denied')
```

**Why console.log in Renderer:**
- Shows in DevTools for debugging
- electron-log doesn't capture renderer console (main process only)
- Separate from main process logging

---

## Build System & Distribution

### Build Scripts

| Script | Purpose |
|---------|---------|
| `npm run dev` | Start Vite dev server + Electron watch mode |
| `npm run build` | Local test build (no signing) |
| `npm run build:prod` | Production build (signed + notarized) |
| `npm run install:browsers` | Install Playwright browsers |
| `npm run generate-icons` | Generate app icons |

---

### Local Test Build (`npm run build`)

**What It Does:**

1. Generates `build-info.json` with git commit hash and build timestamp
2. Builds React frontend with Vite to `dist/`
3. Runs `electron-builder` with `electron-builder.test.json`
4. Builds macOS ARM64 only
5. Creates unsigned `.dmg` and `.zip` files in `release/`

**Output:** `release/Dodo Recorder-<version>-arm64.dmg`

**Platform Support:** macOS ARM64 only

**Signing:** None (identity set to `null`)

**Configuration (`electron-builder.test.json`):**
```json
{
  "appId": "com.dodorecorder.app",
  "productName": "Dodo Recorder",
  "directories": {
    "output": "release"
  },
  "files": [
    "dist/**/*",
    "dist-electron/**/*"
  ],
  "extraResources": [
    "models/**/*",
    "node_modules/ffmpeg-static/**/*"
  ],
  "mac": {
    "target": ["dmg", "zip"],
    "icon": "build/icon.icns",
    "hardenedRuntime": false,
    "type": "development"
  }
}
```

---

### Production Build (`npm run build:prod`)

**What It Does:**

1. Loads environment variables from `.env` file
2. Generates `build-info.json`
3. Builds React frontend with Vite to `dist/`
4. Detects current platform and builds accordingly:
   - **macOS ARM64**: Signed + notarized `.dmg` and `.zip`
   - **Windows x64**: NSIS installer + portable executable
5. Creates output in `release/` directory

**Output:**
- macOS: `Dodo Recorder-<version>-arm64.dmg`, `Dodo Recorder-<version>-arm64-mac.zip`
- Windows: `Dodo Recorder Setup <version>.exe`, `Dodo Recorder <version>.exe` (portable)

**Platform Support:** macOS ARM64, Windows x64

---

### macOS Code Signing & Notarization

**Requirements (for maintainer only):**

1. **Apple Developer Certificate** (Developer ID Application)
2. **Apple ID** + **App-specific Password**
3. **Apple Team ID**

**Environment Variables:**

```bash
APPLE_ID="your-apple-id@example.com"
APPLE_APP_SPECIFIC_PASSWORD="abcd-efgh-ijkl-mnop"
APPLE_TEAM_ID="L7PUGF6Q28"

# Optional: Explicit certificate file
CSC_LINK=./certificate.p12
CSC_KEY_PASSWORD=your-p12-password
```

**Configuration (`electron-builder.json`):**

```json
{
  "mac": {
    "target": ["dmg", "zip"],
    "icon": "build/icon.icns",
    "entitlements": "build/entitlements.mac.plist",
    "entitlementsInherit": "build/entitlements.mac.plist",
    "extendInfo": {
      "NSMicrophoneUsageDescription": "Dodo Recorder needs microphone access to record voice commentary during test sessions."
    },
    "hardenedRuntime": true,
    "gatekeeperAssess": false,
    "category": "public.app-category.developer-tools",
    "type": "distribution",
    "notarize": {
      "teamId": "L7PUGF6Q28"
    }
  }
}
```

**Entitlements (`build/entitlements.mac.plist`):**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
  <false/>
  <key>com.apple.security.cs.disable-library-validation</key>
  <false/>
</dict>
</plist>
```

---

### CI/CD Pipeline (GitHub Actions)

**Trigger:** Manual only via GitHub Actions UI

**Jobs:**

1. **build-macos-arm64** (runs on macOS-latest)
   - Checkout code
   - Setup Node.js 18
   - Cache npm dependencies
   - Cache Playwright browsers
   - Install dependencies
   - Download Whisper model
   - Import code signing certificate
   - Build with `npm run build:prod`
   - Upload artifacts (`.dmg`, `.zip`)

2. **build-windows** (runs on windows-latest)
   - Checkout code
   - Setup Node.js 18
   - Cache npm dependencies
   - Cache Playwright browsers
   - Install dependencies
   - Download Whisper model
   - Build with `npm run build:prod`
   - Upload artifacts (`.exe`)

3. **upload-to-release** (if `release_tag` provided)
   - Download all artifacts
   - Upload to GitHub Release

---

### Binaried & Models

**Whisper Binaries (committed to git):**
- `models/unix/whisper` (macOS ARM64)
- `models/win/whisper-cli.exe` (Windows x64)

**Whisper Model (downloaded manually):**
- `models/ggml-small.en.bin` (466 MB)

**Download Command:**
```bash
curl -L -o models/ggml-small.en.bin https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-small.en.bin
```

**Why Model Not in Git:**
- 466 MB too large for git repositories
- Downloaded once per machine
- Persists across npm installs

---

### Playwright Browsers

**Auto-Installed via postinstall:**
```bash
npm install  # Runs build/install-playwright-browsers.js
```

**Manual Install:**
```bash
npm run install:browsers
```

**Location:** `playwright-browsers/` directory

**Bundled:** Included in app via `extraResources` in electron-builder config

---

## Known Issues & TODO

### Known Bugs

1. **Pause + Stop Crash**
   - **Issue:** Process crashes when recording paused in browser widget and user clicks "Stop" in app UI
   - **Status:** Open TODO item
   - **Location:** `electron/ipc/recording.ts`, `electron/browser/recorder.ts`

2. **Widget Rendering Issues**
   - **Issue:** Sometimes widget doesn't render on certain websites (e.g., youtube.com)
   - **Status:** Open TODO item
   - **Likely Cause:** Timing issues, CSP blocking, Shadow DOM conflicts
   - **Location:** `electron/browser/recorder.ts`, `electron/browser/recording-widget.ts`

3. **Dev Mode Window Popping to Top**
   - **Issue:** Electron app pops on top of all other windows during HMR in dev mode
   - **Status:** Open TODO item
   - **Likely Cause:** Vite HMR triggers window focus
   - **Location:** `vite.config.ts`, `electron/main.ts`

---

### Planned Features (TODO)

1. **Audio Volume Monitoring**
   - **Goal:** Monitor audio input volume during recording
   - **Implementation:** Listen to audio stream, check threshold
   - **Behavior:** Warn user if no/little sound detected
   - **Benefit:** Prevent poor recordings

2. **DOM Freezing**
   - **Goal:** Ability to freeze DOM during recording
   - **Use Case:** Capture elements that appear briefly during loading
   - **Behavior:** Freeze DOM, assert/click, refresh/unfreeze
   - **Implementation:** Add exposeFunction in recorder, button in widget

3. **Enhanced Widget Options**
   - **Goal:** More options in browser widget
   - **Inspiration:** Playwright Codegen features
   - **Potential:** Step-through mode, element highlighting, etc.

---

## Development Guidelines

### Code Style

**TypeScript:**
- Strict mode enabled
- No unused locals or parameters
- Explicit return types for public APIs
- Use interfaces for object shapes, types for unions

**React:**
- Function declarations for components (not arrow functions)
- `React.forwardRef` for components needing refs
- Display names for all components

**Imports:**
```typescript
// Group: external â†’ internal â†’ types â†’ assets
import { app, BrowserWindow } from 'electron'
import { logger } from './utils/logger'
import type { RecordedAction } from '@/types/session'
import saurusIcon from '@/assets/saurus.png'

// Use @/* path alias for src/
import { useRecordingStore } from '@/stores/recordingStore'
```

**Naming:**
- Files: `camelCase` (utilities), `PascalCase` (components/classes)
- Functions: `camelCase`, descriptive verb-noun pairs
- Classes: `PascalCase`
- Constants: `UPPER_SNAKE_CASE`
- Props: `PascalCase` with "Props" suffix

---

### Error Handling

**IPC Pattern:**

```typescript
// IpcResult interface
interface IpcResultSuccess<T = object> {
  success: true
  data?: T
}

interface IpcResultError {
  success: false
  error: string
}

export type IpcResult<T = object> = (IpcResultSuccess<T> & T) | IpcResultError

// Validation function
function validateUrl(url: string): { valid: boolean; error?: string } {
  if (!url || typeof url !== 'string') {
    return { valid: false, error: 'URL is required' }
  }
  return { valid: true }
}

// Handler
ipcMain.handle('start-recording', async (event, url, outputPath, startTime) => {
  // Validate
  const urlValidation = validateUrl(url)
  if (!urlValidation.valid) {
    return ipcError(urlValidation.error!)
  }
  
  try {
    // Execute
    await startRecording(url, outputPath, startTime)
    return ipcSuccess()
  } catch (error) {
    logger.error('Failed to start recording:', error)
    return ipcError('Failed to start recording')
  }
})
```

**Try-Catch for Async Operations:**

```typescript
try {
  await this.page.goto(url)
} catch (e) {
  logger.error('Failed to navigate:', e)
  throw new Error('Navigation failed')
}
```

---

### Logging

**Main Process:**
```typescript
import { logger } from './utils/logger'

logger.debug('Detailed debug info')  // Dev only
logger.info('Normal operation')       // Always logged
logger.warn('Warning')
logger.error('Error occurred', error)
```

**Renderer Process:**
```typescript
console.log('ğŸ¬ startRecording() called')
console.error('âŒ Failed to start recording:', error)
console.warn('âš ï¸ Microphone permission denied')
```

**Best Practices:**
- Use emojis for visual scanning
- Include context with errors
- Log state transitions
- Use logger in main process, console in renderer

---

### Security

**IPC Validation:**
- All inputs validated before processing
- See `electron/utils/validation.ts` for patterns

**File Operations:**
- Sanitize paths to prevent directory traversal
- Use `electron/utils/fs.ts` helpers

**Preload Script:**
- `contextIsolation: true`
- `nodeIntegration: false`
- Explicit API exposure

---

## Future Directions

### Short-Term (v0.4.0)

1. **Fix Known Bugs**
   - Pause + stop crash
   - Widget rendering issues
   - Dev mode window focus

2. **Audio Volume Monitoring**
   - Real-time volume feedback
   - Warnings for poor audio
   - Skip transcription if too quiet

3. **Enhanced Widget**
   - More recording options
   - Step-through mode
   - Element highlighting

### Medium-Term (v1.0.0)

1. **Multi-Browser Support**
   - Firefox support
   - Safari support
   - Browser selection in settings

2. **AI Integration**
   - Direct test generation in app
   - Preview generated tests
   - Edit before save

3. **Session Management**
   - Browse saved sessions
   - Compare sessions
   - Merge sessions

### Long-Term (v2.0.0)

1. **Cloud Integration**
   - Optional cloud storage for sessions
   - Team sharing
   - Version history

2. **Advanced Features**
   - Custom assertion patterns
   - Visual regression testing
   - Performance metrics

3. **Framework-Specific Modes**
   - Playwright mode (current)
   - Cypress mode
   - Selenium mode

---

## Summary

**Dodo Recorder** is a sophisticated Electron + React + TypeScript desktop application that enables manual testers to record browser interactions and voice commentary for AI-assisted test generation.

**Key Achievements:**
- âœ… Complete browser recording via Playwright
- âœ… Local voice transcription via Whisper.cpp
- âœ… Intelligent voice-to-action distribution
- âœ… Sentence-level narrative generation
- âœ… AI-optimized session bundles
- âœ… Comprehensive UI with real-time feedback
- âœ… Production-ready logging and debugging
- âœ… Cross-platform builds (macOS ARM64, Windows x64)

**Technical Highlights:**
- Two-process Electron architecture with clean IPC separation
- Shadow DOM isolation for browser widget
- Anti-hallucination filtering for Whisper
- Temporal proximity algorithm for voice distribution
- Token-efficient output format (INSTRUCTIONS.md + actions.json)

**Current State:**
- Version 0.3.0 (production-ready)
- Most features implemented and stable
- Known bugs in TODO
- Active development for v0.4.0

**Why It Matters:**
- Bridges the gap between manual testers and automation engineers
- Enables AI-assisted test generation with human oversight
- Democratizes automated testing
- Reduces friction in testing workflows

---

**Document End**

This deep dive covers everything you might have forgotten about how Dodo Recorder was built. For questions or clarification, refer to the original documentation files in the `docs/` directory or the inline code comments throughout the project.

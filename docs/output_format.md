# Dodo Recorder Output Format

**Last Updated**: January 2026
**Status**: ✅ Production Ready

---

## Table of Contents

1. [Overview](#overview)
2. [Design Goals](#design-goals)
3. [Bundle Structure](#bundle-structure)
5. [File Specifications](#file-specifications)
6. [Usage Examples](#usage-examples)
7. [Token Optimization](#token-optimization)
8. [Framework Support](#framework-support)
9. [Implementation Details](#implementation-details)

---

## Overview

Dodo Recorder produces **framework-agnostic session bundles** optimized for AI-assisted test generation. Each recording session generates a compact, self-contained directory with three essential components:

```
session-YYYY-MM-DD-HHMMSS/
├── INSTRUCTIONS.md    # General, reusable AI instructions
├── actions.json       # Session data + narrative (all-in-one)
└── screenshots/       # Visual captures
```

### Key Features

- **Compact structure** - only 3 essential components
- **Single file processing** - all session data in actions.json
- **Reusable instructions** - INSTRUCTIONS.md shared across all sessions
- **Framework detection** - automatic Playwright/Cypress identification
- **Token-optimized** - efficient use of tokens for LLM processing

---

## Design Goals

### Minimal & Essential
- Only necessary files, zero redundancy
- No duplicate information across files
- Each file serves a distinct purpose

### Framework-Agnostic
- Works with Playwright, Cypress, Selenium, Puppeteer, any framework
- No framework-specific assumptions in action data
- Universal locator strategies

### AI-Instruction-Complete
- Standalone documentation - no external references needed
- Complete parsing instructions included
- Self-documenting format

### Human-Readable
- Clear structure engineers can quickly understand
- Meaningful metadata and narrative flow
- Well-organized action data

### LLM-Optimized
- Single narrative file with complete context
- Reusable instructions reduce per-session overhead
- Efficient token usage for multiple sessions

---

## Bundle Structure

### Component Breakdown

| Component | Purpose | Reusability | Size |
|-----------|---------|-------------|------|
| **INSTRUCTIONS.md** | General framework-agnostic and framework-specific instructions | ✅ Shared across all sessions | ~2,000 tokens |
| **actions.json** | Session-specific data: metadata, narrative, actions | ❌ Unique per session | ~3,850 tokens |
| **screenshots/** | Visual captures with filenames referenced in actions | ❌ Unique per session | Variable |

### Why This Structure?

**INSTRUCTIONS.md is reusable** because it contains:
- General parsing instructions (action reference format, locator strategies)
- Framework detection logic (how to identify Playwright/Cypress projects)
- Framework-specific code patterns (Playwright/Cypress examples)
- Best practices (which locators to prefer, how to structure tests)

**actions.json is session-specific** because it contains:
- Unique session metadata (ID, timestamp, URL, duration)
- Narrative text with embedded action references
- Array of recorded actions with locators

This separation means INSTRUCTIONS.md is read **once** by an AI agent, then all subsequent sessions only require reading actions.json.

---

## File Specifications

### 1. INSTRUCTIONS.md

**Format**: Markdown  
**Encoding**: UTF-8  
**Size**: ~150 lines (~2,000 tokens)  
**Reusability**: ✅ Shared across all sessions in the same output directory

**Content Sections**:

1. **Overview** (3-5 lines)
   - What are Dodo Recorder session bundles
   - Framework-agnostic nature

2. **Bundle Structure** (3 lines)
   - List of files and their purposes

3. **How to Process Session Bundles** (5 subsections, ~30 lines)
   - Read actions.json
   - Parse action references
   - Choose locator strategies
   - Interpret action types
   - Use voice commentary

4. **Framework-Specific Implementation** (3 subsections, ~80 lines)
   - **Detecting Framework**: How to identify Playwright/Cypress projects
   - **Playwright Implementation Guide**: Code structure, locator mapping, best practices
   - **Cypress Implementation Guide**: Code structure, locator mapping, best practices
   - **Empty Repository**: What to do when no framework is detected

5. **Format Version** (3 lines)
   - Version number, generated by, compatibility

**Key Features**:
- No session-specific information
- Framework-agnostic language with framework-specific examples
- Actionable instructions with code samples
- Locator priority guidance

**Example Structure**:
```markdown
# Dodo Recorder - Session Bundle Instructions

## Overview
Dodo Recorder session bundles are framework-agnostic recordings...

## Bundle Structure
- **INSTRUCTIONS.md** (this file) - How to process session bundles
- **actions.json** - Complete session data
- **screenshots/** - Visual captures

## How to Process Session Bundles

### 1. Read actions.json
The file contains...

[... continues with detailed instructions ...]

## Framework-Specific Implementation

### Detecting Framework
#### Playwright Project
Check for these files in repository root:
- `playwright.config.ts` or `playwright.config.js`
- `package.json` with `@playwright/test` dependency

[... continues with framework patterns ...]
```

---

### 2. actions.json

**Format**: JSON (pretty-printed, 2-space indent)  
**Encoding**: UTF-8  
**Size**: ~3,850 tokens for typical 29-action session

**TypeScript Interface**:
```typescript
interface ActionsJson {
  _meta: {
    formatVersion: "2.0"
    generatedBy: string
    sessionId: string           // session-YYYY-MM-DD-HHMMSS
    startTime: number            // Unix timestamp ms
    startTimeISO: string         // ISO 8601 format
    duration: string             // Human-readable (e.g., "3m 45s")
    startUrl?: string            // First navigate action URL
    totalActions: number
    actionTypes: Record<string, number>  // { "click": 5, "fill": 2, ... }
  }
  narrative: {
    text: string  // Voice commentary with [action:SHORT_ID:TYPE] references
    note: string  // Fixed explanation of action reference format
  }
  actions: RecordedAction[]  // Array of actions without voiceSegments
}
```

**Example**:
```json
{
  "_meta": {
    "formatVersion": "2.0",
    "generatedBy": "Dodo Recorder",
    "sessionId": "session-2026-01-23-102150",
    "startTime": 1737628910000,
    "startTimeISO": "2026-01-23T10:21:50.000Z",
    "duration": "8s",
    "startUrl": "https://github.com/pricing",
    "totalActions": 10,
    "actionTypes": {
      "assert": 4,
      "screenshot": 2,
      "click": 1,
      "navigate": 3
    }
  },
  "narrative": {
    "text": "This is the recording, I'm just editing on these elements... [action:c8d39f77:assert] [action:aa42301c:assert]...",
    "note": "Voice commentary with embedded action references. Match SHORT_ID (first 8 chars) with action.id in actions array."
  },
  "actions": [
    {
      "id": "c8d39f77-176a-4b5a-9209-9558c2f4dbf8",
      "timestamp": 4958,
      "type": "assert",
      "target": {
        "selector": "getByText('\\bOpen\\b \\bSource\\b')",
        "locators": [
          {
            "strategy": "text",
            "value": "getByText('\\bOpen\\b \\bSource\\b')",
            "confidence": "medium"
          },
          {
            "strategy": "css",
            "value": "ul > li:nth-of-type(4) > div > button",
            "confidence": "low"
          }
        ],
        "role": "button",
        "name": "Open Source",
        "text": "Open Source",
        "tagName": "button",
        "innerText": "Open Source",
        "boundingBox": { "x": 402, "y": 16, "width": 134, "height": 40 }
      }
    }
  ]
}
```

**Key Fields**:

- **_meta**: Minimal session metadata
- **narrative**: Complete transcript with action references
  - `text`: Voice commentary with `[action:SHORT_ID:TYPE]` embedded
  - `note`: Fixed explanation string (same across all sessions)
- **actions**: Array of recorded actions

**Validation Rules**:
1. All action references in narrative must have corresponding action in actions array
2. SHORT_ID must match first 8 chars of action.id
3. Action types in narrative must match action.type
4. Duration calculated from last.timestamp - first.timestamp
5. actionTypes must sum to totalActions

---

### 3. screenshots/

**Purpose**: Visual captures of browser state during recording  
**Format**: PNG images  
**Naming**: `screenshot-{timestamp}.png`  
**Referenced By**: 
- actions array: `action.screenshot` field
- narrative text: `[screenshot:filename.png]` embedded references


---

## Usage Examples

### For AI Test Generation

**Simple Prompt**:
```
Generate browser automation tests from the session bundle at:
./test-context/session-2026-01-23-102150/

Follow the instructions in INSTRUCTIONS.md.
Use Playwright framework.
```

**AI Workflow**:
1. Reads INSTRUCTIONS.md for complete parsing guidance
2. Reads actions.json for session data
3. Parses narrative for test intent and action sequence
4. Cross-references action IDs (8-char prefix → full UUID)
5. Chooses locators based on confidence levels
6. Generates Playwright test code

### For Human Engineers

**Quick Review**:
```bash
cd session-2026-01-23-102150/
cat actions.json | jq '._meta'           # View session metadata
cat actions.json | jq '.narrative.text'  # View narrative
cat actions.json | jq '.actions[0]'      # View first action
```

**Count Actions**:
```bash
cat actions.json | jq '.actions | length'
```

**Find Action by Short ID**:
```bash
cat actions.json | jq '.actions[] | select(.id | startswith("c8d39f77"))'
```

---

## Token Optimization

### Token Efficiency

**Session Bundle Structure**:
```
session-YYYY-MM-DD-HHMMSS/
├── INSTRUCTIONS.md   ~2,000 tokens (shared, read once)
├── actions.json      ~3,850 tokens (per session)
└── screenshots/
```

**Multi-Session Efficiency**:
- **1 session**: ~5,850 tokens (INSTRUCTIONS.md + actions.json)
- **5 sessions**: ~21,250 tokens total (INSTRUCTIONS.md read once, 5 × actions.json)
- **10 sessions**: ~40,500 tokens total (INSTRUCTIONS.md read once, 10 × actions.json)

**Key Insight**: INSTRUCTIONS.md is reusable across all sessions, so processing multiple sessions becomes increasingly efficient.

---

## Framework Support

### Supported Frameworks

The output format is framework-agnostic and provides specific guidance for:

1. **Playwright** (@playwright/test)
   - Test structure with `test.describe()` and `test()`
   - Locator mapping: `getByTestId()`, `getByText()`, `getByRole()`, etc.
   - Best practices for semantic locators

2. **Cypress** (cypress)
   - Test structure with `describe()` and `it()`
   - Locator mapping: `cy.get()`, `cy.contains()`, etc.
   - Assertion patterns with `.should()`

3. **Other Frameworks**
   - Selenium, Puppeteer, WebdriverIO, etc.
   - Use locator data from actions.json
   - Adapt patterns from Playwright/Cypress examples

### Framework Detection

INSTRUCTIONS.md includes logic for detecting frameworks:

**Playwright Detection**:
- Check for `playwright.config.ts` or `playwright.config.js` in repo root
- Check `package.json` for `@playwright/test` dependency

**Cypress Detection**:
- Check for `cypress.config.ts` or `cypress.config.js` in repo root
- Check for `cypress/` directory
- Check `package.json` for `cypress` dependency

**No Framework Detected**:
- Recommend framework based on project structure
- Provide setup instructions
- Generate test file with framework config
- Include locator data in comments

---

## Implementation Details

### Code Structure

**Core Files**:
- [`electron/session/writer.ts`](../electron/session/writer.ts) - SessionWriter class
- [`electron/session/instructions-template.ts`](../electron/session/instructions-template.ts) - INSTRUCTIONS.md template
- [`electron/utils/enhancedTranscript.ts`](../electron/utils/enhancedTranscript.ts) - Narrative generation
- [`shared/types.ts`](../shared/types.ts) - TypeScript interfaces (ActionsJson, Metadata, NarrativeSection)

### SessionWriter Implementation

**Key Methods**:

1. **`write(session: SessionBundle): Promise<string>`**
   - Main entry point
   - Creates session directory
   - Ensures INSTRUCTIONS.md exists
   - Generates actions.json with embedded narrative
   - Returns session directory path

2. **`ensureInstructionsFile(sessionDir: string): Promise<void>`**
   - Checks if INSTRUCTIONS.md exists
   - Writes template if not present
   - Prevents duplicate writes

3. **`formatDuration(ms: number): string`**
   - Converts milliseconds to human-readable format
   - Examples: "8s", "3m 45s"

**Flow**:
```typescript
async write(session: SessionBundle) {
  // 1. Create session directory
  const sessionDir = createSessionDirectory(session)
  
  // 2. Ensure INSTRUCTIONS.md exists in session directory
  await ensureInstructionsFile(sessionDir)
  
  // 3. Generate narrative text
  const narrativeText = buildNarrativeWithSentenceLevelDistribution(session.actions)
  
  // 4. Build actions.json structure
  const actionsJson = {
    _meta: { /* session metadata */ },
    narrative: { text: narrativeText, note: "..." },
    actions: stripVoiceSegments(session.actions)
  }
  
  // 5. Write actions.json
  await writeJson(path.join(sessionDir, 'actions.json'), actionsJson)
  
  return sessionDir
}
```

### Narrative Generation

Uses `buildNarrativeWithSentenceLevelDistribution()` from [`enhancedTranscript.ts`](../electron/utils/enhancedTranscript.ts):

**Algorithm**:
1. Split voice segments into sentences with timestamps
2. Find closest sentence for each action timestamp
3. Interleave action references within sentences
4. Append actions without voice at the end
5. Return complete narrative text

**Output Format**:
```
"So, this is the test session [action:e6c3069a:navigate]. Now I'm clicking on some
top menu items [action:c5922be3:click] [action:72e42724:click] to assert them..."
```

---

## Summary

### Format Characteristics

**Structure**: 3 components (INSTRUCTIONS.md, actions.json, screenshots/)

**Key Features**:
- ✅ Framework-agnostic (Playwright, Cypress, Selenium, Puppeteer, etc.)
- ✅ AI-instruction-complete (standalone documentation)
- ✅ Self-documenting (all instructions embedded)
- ✅ Token-optimized (efficient reuse of instructions)
- ✅ Reusable instructions (INSTRUCTIONS.md shared)
- ✅ Single file processing (all data in actions.json)
- ✅ Multiple locator strategies with confidence levels
- ✅ Voice commentary synced with actions
- ✅ Complete test intent and context

**Use Cases**:
- AI-assisted test generation across any framework
- Manual test scenario documentation
- Test intent preservation
- Cross-team collaboration
- Test maintenance and debugging

**Final Achievement**:

Any AI agent in any test automation project can now:
1. Open a session bundle
2. Read the reusable INSTRUCTIONS.md once
3. Process actions.json for session-specific data
4. Generate complete, maintainable tests for their framework
5. Work without any project-specific knowledge or custom system prompts

**The format balances**:
- Complete AI instructions (for automation)
- Human readability (for manual review)
- Framework flexibility (works everywhere)
- Minimal complexity (3 components, clear structure)
- Optimal token usage (reusable instructions)
